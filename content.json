{"pages":[],"posts":[{"title":"RAFT实现之leader election","text":"leader选举基本流程 所有节点以follower启动 follower的选举时钟超时，转为candidate candidate向其他节点发送投票请求，如果收到过半节点的投票，则成为leader leader周期性向其他节点发送心跳包以维持权威 实现关键点： 1.状态转移：raft节点的状态转移要严格依据下图，不管节点处于什么状态，只要发现更大的Term，都转为follower。对于candidate，如果收到新leader的心跳包，则转为follower。 2.选举时钟如果节点状态不是leader，选举时钟需要周期性的检查是否过期: 123456789101112131415func (rf *Raft) PeriodicRequestVote() { for { rf.mu.Lock() //检查状态是不是leader,如果不是，检查election time 有没有超时 ，超时，则状态转为candidate if rf.state != leader &amp;&amp; rf.electionTimer+rf.timeperiod &lt; time.Now().UnixNano() { //转到c尝试成为leader rf.mu.Unlock() rf.AttemptBeLeader() } else { rf.mu.Unlock() } // rf.mu.Unlock() time.Sleep(electionInterval*time.Millisecond) } } 重置选举时钟的3种情形： 从leader处收到appendentriesRPC调用（如果leader的term过期则不用重置） 开始新的一轮选举 给其他节点投票（收到requestVoteRPC调用） 3.RequestVoteRPC接受者（follow，candidate，leader）实现除了图中的1、2，还需要注意： 检查是否收到更大的term，如果收到，更新term并转为follower状态，如果已经是follower，则更新term和重置votedFor 1234567//如果候选人的term小于自己的termif term&lt;rf.currentTerm { reply.VoteGranted = false return} else if term &gt; rf.currentTerm { //收到更高的term，更新term,转为follwer rf.convertToFollwer(term)} 如果决定给候选人投票，需要将自己的当前term返回，这里强调当前term（currentTerm）是因为follower可能因为在正式返回投票结果前更新了自己的currentTerm（比如收到更大的term） 123456if (rf.votedFor==-1 || rf.votedFor==candidateid) &amp;&amp; (lastLogTerm &gt; lastTerm || lastLogTerm==lastTerm &amp;&amp; lastLogIndex&gt;=lastIndex) { reply.Term = rf.currentTerm reply.VoteGranted = true //将投票人修改(add my) rf.votedFor=candidateid 发送者收到RPC调用结果后，需要注意： 是否是过期的rpc回复（即term小于自己的term），丢弃不处理 1234 //如果收到过期的term，丢弃 if rf.state!=candidate || reply.Term &lt; rf.currentTerm { return false } 返回的term是否大于自己的term，是则转为follower 1234 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } candidate统计选票时得把自己算上 守护进程定时检查节点是否成为leader，成为leader后定时周期发起AppendEntriesRPC。 123456789101112func (rf *Raft) PeriodicAppendEnties() { for { rf.mu.Lock() if rf.state == leader { rf.mu.Unlock() rf.AttemptReplication() } else { rf.mu.Unlock() } time.Sleep(heartbeatInterval*time.Millisecond) } } 测试全部通过","link":"/2020/05/24/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Bleader-election/"},{"title":"c++常量const","text":"常量 常量值不可更改 123const int val = 20;val = 22;//errorval = 20;//error,不允许有赋值操作 常量指针 const type * 不可通过常量指针修改其指向的内容 1234int val2 = 30;const int * ptr = &amp;val2;*ptr = 40;//errorval2 = 40;//ok,val2不是常量可以更改 type * const不可更改指针值 123int * const ptr2 = &amp;val2;*ptr2 = 50;//okptr2 = ptr;//error 常量引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 常成员函数 类成员函数后面加const关键字 常成员函数不能修改对象的成员变量的值 除了静态成员变量，因为静态成员变量不属于某个对象 常成员函数不能调用类的非常成员函数 非常成员函数可能会修改成员变量的值 除了静态成员函数，因为静态成员函数不属于某个对象123456789101112131415161718class test{ int n;public: test() { n = 1; }; // int set(int i) const {n=i;}//error,常成员函数不能更改成员变量 int set(int i) {} int get() const { return n; } int get() { return n; } //重载};int main() { const test t1; test t2; //t1.set(2);//error,常量对象不能调用非常量成员函数 t2.set(2); cout &lt;&lt; t1.get() &lt;&lt; \" \" &lt;&lt; t2.get() &lt;&lt; endl;}","link":"/2020/05/31/c-%E5%B8%B8%E9%87%8Fconst/"},{"title":"c++内联函数","text":"函数调用是有开销的，对于函数体较小却又多次执行的函数，总的开销就会显得比较大 编译期处理内敛函数的调用语句时，是将函数体的代码插入到调用语句出，这样就不会避免了函数调用。 1234567891011inline int max(int a, int b){ if (a &gt; b) return a; else return b;}int main(){ cout &lt;&lt; max(1, 3) &lt;&lt; endl;} 内联成员函数 成员函数前有inline关键字 成员函数定义在类内部 1234567class testInline{public: void func1(){}; //inline void func2();};inline void testInline::func2() {} //inline","link":"/2020/05/31/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"c++引用和指针","text":"引用 变量的引用等价于该变量，引用就是变量的别名 1234567int n = 4;int &amp;ref = n;//ref引用ncout &lt;&lt;ref&lt;&lt;endl;//4n = 5;//改变ncout&lt;&lt;ref&lt;&lt;endl;//5int &amp;ref2 = ref;cout&lt;&lt;ref2&lt;&lt;endl;//5 引用必须初始化为某个变量 12int &amp;ref2 = 2;//常量，errorint &amp;ref3 = n*5;//表达式，error 引用不能更换引用其他变量 1234int &amp;ref = n;//ref引用nint m = 6;ref = m;//ok,赋值操作ref = &amp;m;//error 常引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 指针","link":"/2020/05/31/c-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/"},{"title":"c++构造函数","text":"构造函数是一种特殊的成员函数，具有如下特点： 名字和类名相同，可以有参数，但是不能有返回值。 负责对对象进行初始化操作，生成对象时调用1次，此后不会被调用。 未定义构造函数，编译器会自动生成一个无参的构造函数，该函数没有任何操作。 构造函数可以被重载。 1234567891011121314151617181920212223242526class Node{private: /* data */ double key,value;public: Node(){}; Node(int k,int v=0); Node(double k,double v); double getKey() {return key;} ~Node(){};};Node::Node(int k,int v) { key = double(k);value = double(v);}Node::Node(double k,double v) { key=k;value=v;}int main() { Node n1; Node n2(1); Node n3(2,3); Node n4(1,2,3);//error，参数个数不匹配 Node *ptr4 = new Node(1.2,2.2); Node *ptr6 = new Node(1.2,2);//error,参数类型不匹配} 复制构造函数 复制构造函数只能有一个参数：同类对象的引用(type &amp; or const type &amp;) 未定义复制构造函数，编译器会自动生成一个复制构造函数。1234567891011121314151617181920class Node{private: /* data */ double key,value;public: Node(){}; Node(const Node&amp; node); ~Node(){};};Node::Node(const Node&amp; node) { key = node.key; value = node.value; cout &lt;&lt; \"copy constructor called\"&lt;&lt;endl;}int main() { Node n1; Node n4(n1); Node * ptr6 = new Node(n1);} 复制构造函数的使用 初始化对象时1Node n2(n1); 函数参数为对象时12345void func(Node node){};int main() { Node n4(3); func(n4);//调用复制构造函数} 函数返回值为对象时,如果没有调用，则是编译期做了优化12345678Node func1() { Node n(3); return n;}int main() { cout &lt;&lt; func1().getKey()&lt;&lt;endl; //如果没有调用复制构造函数，是编译器做了优化，不再产生临时对象} 类型转换构造函数 实现类型的自动转换 只有一个参数 转换构造函数会建立一个临时对象 12345678910111213141516171819class Node{private: /* data */ double key,value;public: Node(){}; Node(int k);//类型转换构造函数 double getKey() {return key;} ~Node(){};};Node::Node(int k) { key = double(k);value = 0; cout &lt;&lt; \"typeTrans constructor called\"&lt;&lt;endl;}int main(){ Node n5; n5 = 6;//类型转换}","link":"/2020/05/31/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"RAFT实现之log Replication","text":"实现要点1.AppendEntriesRPC接收者（follower，candidate）除了实现图中的1~5，还需要注意以下几点： 收到更大的term，或者candidate收到leader的心跳包，转为follower 1234567 //收到更高的term，更新term,转为follwer if leaderTerm &gt; rf.currentTerm { rf.convertToFollwer(leaderTerm)//候选人收到leader的心跳包，转为follwer } else if leaderTerm == rf.currentTerm &amp;&amp; rf.state == candidate { rf.convertToFollwer(leaderTerm) } 如果follower日志和leader的冲突，需要将冲突信息（conflictTerm、conflictIndex）返回给leader，这里是论文中的方法优化版，可以让leader迅速定位冲突的日志位置。 1234567891011121314151617181920212223 if prevLogIndex &gt;= len(rf.log) {//如果prevLogIndex处的日志不存在 reply.Success = false reply.ConflictIndex = len(rf.log) reply.ConflictTerm = -1 return //如果prevLogIndex的日志存在，但是term不一致 } else if rf.log[prevLogIndex].Term != prevLogTerm { reply.Success = false reply.ConflictTerm = rf.log[prevLogIndex].Term flag := false //返回冲突term的最开始的index for i:=prevLogIndex-1;i&gt;=0;i-- { if rf.log[i].Term != reply.ConflictTerm { reply.ConflictIndex = i+1 flag = true break; } } if !flag { reply.ConflictIndex = 0 } return } 2.RPC回复处理发送者（leader）收到rpc调用的回复后，需要注意以下几点： 收到更大的term或过期的term，做相应的处理 12345678 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } //如果收到过期的term,丢弃 if rf.state!=leader || reply.Term &lt; rf.currentTerm { return false } 正确的更新nextIndex、matchIndex，根据rpc调用时的entries的长度来更新，而不是自己的log长度 12rf.nextIndex[serverid] = args.PrevLogIndex+len(args.Entries)+1rf.matchIndex[serverid] = args.PrevLogIndex+len(args.Entries) 要迅速定位和follower的冲突日志的index，以一个term为单位来检查是否有冲突，而不是一个个entry来找 12345678910111213141516 //加速检查 firstConflict := reply.ConflictIndex if reply.ConflictTerm != -1 { flag := false for i,entry := range rf.log { if entry.Term == reply.ConflictTerm { if !flag { flag = true } firstConflict = i } else if flag { break } } } rf.nextIndex[serverid] = firstConflict 3.提交状态机一个守护进程周期性的检查能否提交状态机 123456789101112131415161718192021func (rf *Raft) PeriodicApplyMsg() { for { //检查commitIndex &gt; lastApplied //大于则增加lastApplied,并提交到状态机 rf.mu.Lock() var applyLogs []entry commitIndex := rf.commitIndex lastApply := rf.lastApplied if commitIndex &gt; lastApply { applyLogs = rf.log[lastApply+1:commitIndex+1] rf.lastApplied = commitIndex } rf.mu.Unlock() if len(applyLogs) &gt; 0 { for i,entry := range applyLogs { rf.applyCh &lt;- ApplyMsg{true,entry.Command,lastApply+1+i} } } time.Sleep(10*time.Millisecond) }} 这里需要注意两点： 1. 提交的时候不要给applyCh加锁，因为上锁会阻塞channel（？？？理由待验证） 2. 为了效率，要一次性把能提交的一块提交。 测试通过","link":"/2020/05/31/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Blog-Replication/"},{"title":"c++ static","text":"静态成员变量 成员变量前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局变量 使用静态变量必须在类外部初始化 123456789101112class testStatic{private: int m;public: static int n;};//外部初始化int testStatic::n = 0;int main() { cout&lt;&lt;sizeof(testStatic)&lt;&lt;endl;//4} 如何访问? 类名::成员变量名1testStatic::n 对象名.成员变量名12testStatic t1;t1.n; 指针-&gt;成员变量名12testStatic *ptr = t2;t2-&gt;n; 引用-&gt;成员变量名12testStatic &amp;ptr = t2;t2-&gt;n; 静态成员函数 成员函数前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局函数 不能访问非静态成员变量 不能调用非静态成员函数1234567891011class testStatic{private: int m;public: static int n; static void prinfs(){ cout&lt;&lt;n&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl;//error,不能访问非static成员变量 }}; 静态成员函数访问方法和静态成员变量一致。","link":"/2020/06/01/c-static/"},{"title":"c++ this","text":"this指针指向成员函数所作用的对象 静态成员函数不能使用this指针 因为静态成员函数不属于某个对象 123456789101112131415class testThis{ int n;public: void hello() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } void printn() { cout &lt;&lt; this-&gt;n &lt;&lt; endl; }};int main(){ testThis *ptr = NULL; ptr-&gt;hello();//ok,函数体为用到this指针 ptr-&gt;printn();//error,this指针为空}","link":"/2020/06/01/c-this/"},{"title":"c++析构函数","text":"析构函数在对象消亡时会被自动调用，用于释放内存空间等操作 析构函数与类名相同 没有参数和返回值 不能重载，只能有一个析构函数 没有定义析构函数，编译期会自动生成析构函数，该析构函数不做任何事 123456789101112131415161718class String{private: char *p;public: String() { p = new char[10]; }; ~String();};String::~String(){ delete[] p; cout &lt;&lt; \"destructor called\"&lt;&lt;endl;} 一个对象生命周期结束时会调用析构函数； 如果是对象数组，则数组中的每个对象的析构函数都会被调用; 如果是指针类型，需要通过delete来调用析构函数123456int main() { String str; String strlist[3]; String * ptr = new String; delete ptr;} 输出12345destructor called //strdestructor called //strlist[0]destructor called //strlist[1]destructor called //strlist[2]destructor called //*ptr 同一作用域内，先构造的对象后析构 123456789101112131415161718192021222324252627282930313233343536class String{private: int id;public: String(){}; String(int i); String(char ch); ~String();};String::~String(){ cout &lt;&lt; id &lt;&lt; \" destructor called\" &lt;&lt; endl;}String::String(int i){ id = i; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;};String::String(char ch){ id = ch - '0'; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;}int main(){ String str1(1); str1 = '6'; if (1) { String str2(2); } String str3(3);} 输出123456781 constructor called6 constructor called 6 destructor called //赋值是生成的临时变量2 constructor called2 destructor called3 constructor called3 destructor called6 destructor called","link":"/2020/06/01/c-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"title":"c++重载","text":"运算符重载 c++中预定义的运算符最初只能对基本的数据类型进行操作。 对已有的运算符赋予多重的含义。 使同一运算符作用于不同类型的数据时，有不同类型的行为。 目的扩展C++中提供的运算符的适用范围, 以用于类所表示的抽象数据类型。 运算符重载需要注意： 运算符重载不改变运算符的优先级 以下运算符不能被重载： “.”, “.*”, “::”, “?:”, sizeof 重载运算符(), [ ], -&gt;或者赋值运算符=时, 重载函数必须声明为类的成员函数 原理在程序编译时: 把含运算符的表达式 –&gt; 对运算符函数的调用 把运算符的操作数 –&gt; 运算符函数的参数 运算符被多次重载时, 根据实参的类型决定调用哪个运算符函数 重载为普通函数 参数个数为运算符目数 12345678910111213141516171819class complex{public: double r, i; complex(double a, double b) { a = r; b = i; }};complex operator+ (const complex&amp; a,const complex&amp; b) { return complex(a.r+b.r,a.i+b.i);}int main(){ complex a(1,1),b(2,1),c; c=a+b;//==&gt;c=operator+(a,b)} 重载为成员函数 参数个数为运算符目数减一 1234567891011121314151617181920class complex{public: double r, i; complex(){}; complex(double a, double b) { a = r; b = i; } //重载为成员函数 complex operator-(const complex&amp; b) { return complex(r-b.r,i-b.i); }};int main(){ complex a(1,1),b(2,1),c; c = a-b;//==&gt;c = a.operator-(b)} 赋值运算符重载正常情况下，赋值运算符可作用于自定义的数据类型上，比如定义了一个字符串类： 12345678910111213class myString{ char *str; int size;public: myString() : str(NULL),size(0) {} myString(const char *s); myString(const myString &amp;s); void printaddr() { cout &lt;&lt; (void *)str &lt;&lt; endl; } void printstring() { cout &lt;&lt; str &lt;&lt; endl; } int length() {return size;} ~myString() { if(str) delete [] str; }}; 如果使用=来进行赋值操作会发生什么呢? 12345678910int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce70} 所以原始的=赋值只会简单把成员变量的值变得相同，这种赋值就是浅拷贝，对于上面这个例子，仅仅是将两个指针变得指向同一份数据。这种浅拷贝的方式会有如下问题： 指针原来指向的数据没有被释放，变成垃圾内存。 如果一个指针提前释放内存中的数据，那么另一个指针就会变成野指针。 指针指向内存地址会被释放两次，可能会出现内存错误。 为了避免上述问题，我们需要另一种赋值方式-深拷贝。深拷贝是将指针指向的值拷贝过去，而不是指针本身。为了在自己定义的类中实现这个目标，需要我们定义赋值运算符重载函数 1234567891011121314151617181920212223242526272829myString &amp;myString::operator=(const myString &amp;s){ if (str == s.str) return *this; if (s.str) { if (size&lt;s.size) if(str) delete[] str; str = new char[s.size + 1]; strcpy(str, s.str); size = strlen(s.str); } else { str = NULL; size = 0; } return *this;}int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90} 这里将返回值定义为myString&amp;是为了能实现连续赋值，考虑以下情形： 1234myString str1(\"abc\"),str2(\"cde\"),str3(\"efg\");(str1 = str2) = str3;//(str1.opreator=(str2)).opreator=(str3)str1.printstring();//efg 第一次赋值为str1=str2,其返回值我们暂记作xxx;第二次赋值为xxx=str3;这段代码的目的是将str3的值赋给str1，如果返回值不为引用myString&amp;，那么xxx就是一个临时产生对象，不会对str1有任何影象。 []运算符重载 []运算重载需要注意返回值的类型，应当返回引用类型，这样才可以去修改数组指定下标的值。 12345678910char&amp; myString::operator[](int i) { return str[i];}int main(){ myString str1(\"abc\"); cout&lt;&lt;str1[1]&lt;&lt;endl;//a str1[0]='9'; str1.printstring();//abc} &lt;&lt;和&gt;&gt;运算符重载运算符&lt;&lt;和运算符&gt;&gt;原始含义是二进制算数左移和二进制算术右移，在ostream类和istream类中将他们重载为输出流和输入流。 12345678910ostream &amp; ostream::operator&lt;&lt;(int n){ …… //输出n的代码 return * this;}istream &amp; istream::operator&gt;&gt;(int&amp; n){ …… //输入s的代码 return * this;} 可以看到返回值均为ostream和istream类的引用，这里为了能实现输出/输入拼接。 1cout&lt;&lt;\"hello\"&lt;&lt;\"world\"; 那么如果想用ostream或istream对我们自定义的myString类执行输入输出是否可行呢？ 12myString str(\"hello\");cout &lt;&lt;str&lt;&lt;endl;//error 显然不行，因为ostream类中并没有将&lt;&lt;重载为适合myString类的输出函数，所以需要我们自己重载&lt;&lt;运算符，显然我们无法在ostream的成员函数中重载，因此我们只能重载一个普通的全局函数。为了方便访问对象中的私有数据，声明为友元函数。 1234567891011121314151617181920class myString{ char *str; int size;public: ... friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s); friend istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s);};ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s) { out&lt;&lt;s.str; return out;}istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s) { if(!s.str) { s.str = new char[20]; } in &gt;&gt;s.str; return in;} 这样便可以使用cin和cout来自输入输出了 123myString str;cin &gt;&gt; str;cout&lt;&lt;str&lt;&lt;endl; ++和–运算符重载++和–运算符有前置/后置之分，即++i和i++是有区别的。 前置是一元运算符：++i/–i 重载为成员函数: T &amp; operator++(); T &amp; operator–(); 重载为全局函数： T &amp; operator++(T &amp;); T &amp; operator–(T &amp;); 后置运算符作为二元运算符重载:i++/i– 多写一个参数, 仅为了区分前后置，具体无意义 重载为成员函数: T operator++(int); T operator–(int); 重载为全局函数: T operator++(T &amp;, int); T operator–(T &amp;, int);","link":"/2020/06/03/c-%E9%87%8D%E8%BD%BD/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"raft","slug":"raft","link":"/tags/raft/"}],"categories":[]}