{"pages":[],"posts":[{"title":"RAFT实现之leader election","text":"leader选举基本流程 所有节点以follower启动 follower的选举时钟超时，转为candidate candidate向其他节点发送投票请求，如果收到过半节点的投票，则成为leader leader周期性向其他节点发送心跳包以维持权威 实现关键点： 1.状态转移：raft节点的状态转移要严格依据下图，不管节点处于什么状态，只要发现更大的Term，都转为follower。对于candidate，如果收到新leader的心跳包，则转为follower。 2.选举时钟如果节点状态不是leader，选举时钟需要周期性的检查是否过期: 123456789101112131415func (rf *Raft) PeriodicRequestVote() { for { rf.mu.Lock() //检查状态是不是leader,如果不是，检查election time 有没有超时 ，超时，则状态转为candidate if rf.state != leader &amp;&amp; rf.electionTimer+rf.timeperiod &lt; time.Now().UnixNano() { //转到c尝试成为leader rf.mu.Unlock() rf.AttemptBeLeader() } else { rf.mu.Unlock() } // rf.mu.Unlock() time.Sleep(electionInterval*time.Millisecond) } } 重置选举时钟的3种情形： 从leader处收到appendentriesRPC调用（如果leader的term过期则不用重置） 开始新的一轮选举 给其他节点投票（收到requestVoteRPC调用） 3.RequestVoteRPC接受者（follow，candidate，leader）实现除了图中的1、2，还需要注意： 检查是否收到更大的term，如果收到，更新term并转为follower状态，如果已经是follower，则更新term和重置votedFor 1234567//如果候选人的term小于自己的termif term&lt;rf.currentTerm { reply.VoteGranted = false return} else if term &gt; rf.currentTerm { //收到更高的term，更新term,转为follwer rf.convertToFollwer(term)} 如果决定给候选人投票，需要将自己的当前term返回，这里强调当前term（currentTerm）是因为follower可能因为在正式返回投票结果前更新了自己的currentTerm（比如收到更大的term） 123456if (rf.votedFor==-1 || rf.votedFor==candidateid) &amp;&amp; (lastLogTerm &gt; lastTerm || lastLogTerm==lastTerm &amp;&amp; lastLogIndex&gt;=lastIndex) { reply.Term = rf.currentTerm reply.VoteGranted = true //将投票人修改(add my) rf.votedFor=candidateid 发送者收到RPC调用结果后，需要注意： 是否是过期的rpc回复（即term小于自己的term），丢弃不处理 1234 //如果收到过期的term，丢弃 if rf.state!=candidate || reply.Term &lt; rf.currentTerm { return false } 返回的term是否大于自己的term，是则转为follower 1234 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } candidate统计选票时得把自己算上 守护进程定时检查节点是否成为leader，成为leader后定时周期发起AppendEntriesRPC。 123456789101112func (rf *Raft) PeriodicAppendEnties() { for { rf.mu.Lock() if rf.state == leader { rf.mu.Unlock() rf.AttemptReplication() } else { rf.mu.Unlock() } time.Sleep(heartbeatInterval*time.Millisecond) } } 测试全部通过","link":"/2020/05/24/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Bleader-election/"},{"title":"c++常量const","text":"常量 常量值不可更改 123const int val = 20;val = 22;//errorval = 20;//error,不允许有赋值操作 常量指针 const type * 不可通过常量指针修改其指向的内容 1234int val2 = 30;const int * ptr = &amp;val2;*ptr = 40;//errorval2 = 40;//ok,val2不是常量可以更改 type * const不可更改指针值 123int * const ptr2 = &amp;val2;*ptr2 = 50;//okptr2 = ptr;//error 常量引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 常成员函数 类成员函数后面加const关键字 常成员函数不能修改对象的成员变量的值 除了静态成员变量，因为静态成员变量不属于某个对象 常成员函数不能调用类的非常成员函数 非常成员函数可能会修改成员变量的值 除了静态成员函数，因为静态成员函数不属于某个对象123456789101112131415161718class test{ int n;public: test() { n = 1; }; // int set(int i) const {n=i;}//error,常成员函数不能更改成员变量 int set(int i) {} int get() const { return n; } int get() { return n; } //重载};int main() { const test t1; test t2; //t1.set(2);//error,常量对象不能调用非常量成员函数 t2.set(2); cout &lt;&lt; t1.get() &lt;&lt; \" \" &lt;&lt; t2.get() &lt;&lt; endl;}","link":"/2020/05/31/c-%E5%B8%B8%E9%87%8Fconst/"},{"title":"c++内联函数","text":"函数调用是有开销的，对于函数体较小却又多次执行的函数，总的开销就会显得比较大 编译期处理内敛函数的调用语句时，是将函数体的代码插入到调用语句出，这样就不会避免了函数调用。 1234567891011inline int max(int a, int b){ if (a &gt; b) return a; else return b;}int main(){ cout &lt;&lt; max(1, 3) &lt;&lt; endl;} 内联成员函数 成员函数前有inline关键字 成员函数定义在类内部 1234567class testInline{public: void func1(){}; //inline void func2();};inline void testInline::func2() {} //inline","link":"/2020/05/31/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"c++引用和指针","text":"引用 变量的引用等价于该变量，引用就是变量的别名 1234567int n = 4;int &amp;ref = n;//ref引用ncout &lt;&lt;ref&lt;&lt;endl;//4n = 5;//改变ncout&lt;&lt;ref&lt;&lt;endl;//5int &amp;ref2 = ref;cout&lt;&lt;ref2&lt;&lt;endl;//5 引用必须初始化为某个变量 12int &amp;ref2 = 2;//常量，errorint &amp;ref3 = n*5;//表达式，error 引用不能更换引用其他变量 1234int &amp;ref = n;//ref引用nint m = 6;ref = m;//ok,赋值操作ref = &amp;m;//error 常引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 左值引用和右值引用 本节转自[https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/] 右值引用 (Rvalue Referene) 是 C++11中引入的新特性 , 它实现了转移语义 (Move Sementics) 和精确传递 (Perfect Forwarding)。它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数 C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。右值是指临时的对象，它们只在当前的语句中有效。 12int i = 0;//0是右值，i是左值i&gt;10?i:j;//10是右值,i,j是左值 c++11之前是无法引用右值的，c++11之后变支持引用右值。为了和左值引用区分，右值引用的符号是”&amp;&amp;”。 12345678910111213void print(int &amp; n) { cout &lt;&lt; \"left reference \"&lt;&lt;n&lt;&lt;endl;}void print(int &amp;&amp; n) { cout &lt;&lt; \"right reference \"&lt;&lt;n&lt;&lt;endl;}int main { int &amp;&amp; x = 5;//右值引用 int y = 6; print(10); print(x); print(y);} 运行结果： 123right reference 10left reference 5left reference 6 可以看到用临时对象传参时，调用的时使用右值引用的print。注意到使用”x”传参时，并不是作为右值引用，而是作为左值引用。因为x并不是一个临时对象，5是临时对象。 move语义右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。通过转移语义，临时对象中的资源能够转移其它的对象里。转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。 在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。普通的函数和操作符也可以利用右值引用操作符实现转移语义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MyString{private: char *_data; size_t _len; void _init_data(const char *s) { _data = new char[_len + 1]; memcpy(_data, s, _len); _data[_len] = '\\0'; }public: MyString() { _data = NULL; _len = 0; } MyString(const char *p) { _len = strlen(p); _init_data(p); } MyString(const MyString &amp;str) { _len = str._len; _init_data(str._data); std::cout &lt;&lt; \"Copy Constructor is called! source: \" &lt;&lt; str._data &lt;&lt; std::endl; } MyString &amp;operator=(const MyString &amp;str) { if (this != &amp;str) { _len = str._len; _init_data(str._data); } std::cout &lt;&lt; \"Copy Assignment is called! source: \" &lt;&lt; str._data &lt;&lt; std::endl; return *this; } virtual ~MyString() { if (_data) free(_data); }};int main(){ MyString a; a = MyString(\"Hello\"); std::vector&lt;MyString&gt; vec; vec.push_back(MyString(\"World\"));} 运行结果： 12Copy Assignment is called! source: Hello Copy Constructor is called! source: World MyString(“Hello”) 和 MyString(“World”) 都是临时对象，也就是右值。虽然它们是临时的，但程序仍然调用了拷贝构造和拷贝赋值，造成了没有意义的资源申请和释放的操作。如果能够直接使用临时对象已经申请的资源，既能节省资源，有能节省资源申请和释放的时间。这正是定义转移语义的目的。定义转移构造函数和转移赋值函数： 1234567891011121314151617181920MyString(MyString &amp;&amp;str){ std::cout &lt;&lt; \"Move Constructor is called! source: \" &lt;&lt; str._data &lt;&lt; std::endl; _len = str._len; _data = str._data; str._len = 0; str._data = NULL;}MyString &amp;operator=(MyString &amp;&amp;str){ std::cout &lt;&lt; \"Move Assignment is called! source: \" &lt;&lt; str._data &lt;&lt; std::endl; if (this != &amp;str) { _len = str._len; _data = str._data; str._len = 0; str._data = NULL; } return *this;} 需要注意以下几点： 参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”。 参数（右值）不可以是常量，因为我们需要修改右值。 参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。 运行结果 12Move Assignment is called! source: Hello Move Constructor is called! source: World 由此看出，编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符。节省了资源，提高了程序运行的效率。 有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。 标准库函数 std::move既然编译器只对右值引用才能调用转移构造函数和转移赋值函数，而所有命名对象都只能是左值引用，如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用，怎么做呢？标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。 示例程序 : 12345678910111213void ProcessValue(int&amp; i) { std::cout &lt;&lt; \"LValue processed: \" &lt;&lt; i &lt;&lt; std::endl; } void ProcessValue(int&amp;&amp; i) { std::cout &lt;&lt; \"RValue processed: \" &lt;&lt; i &lt;&lt; std::endl; } int main() { int a = 0; ProcessValue(a); ProcessValue(std::move(a)); } 运行结果 : 12LValue processed: 0 RValue processed: 0 std::move在提高 swap 函数的的性能上非常有帮助，一般来说，swap函数的通用定义如下： 123456template &lt;class T&gt; swap(T&amp; a, T&amp; b) { T tmp(a); // copy a to tmp a = b; // copy b to a b = tmp; // copy tmp to b } 有了 std::move，swap 函数的定义变为 : 123456template &lt;class T&gt; swap(T&amp; a, T&amp; b) { T tmp(std::move(a)); // move a to tmp a = std::move(b); // move b to a b = std::move(tmp); // move tmp to b } 通过 std::move，一个简单的 swap 函数就避免了 3 次不必要的拷贝操作。 精确传递 (Perfect Forwarding)本文采用精确传递表达这个意思。”Perfect Forwarding”也被翻译成完美转发，精准转发等，说的都是一个意思。 精确传递适用于这样的场景：需要将一组参数原封不动的传递给另一个函数。 “原封不动”不仅仅是参数的值不变，在 C++ 中，除了参数值之外，还有一下两组属性： 左值／右值和 const/non-const。 精确传递就是在参数传递过程中，所有这些属性和参数值都不能改变。在泛型函数中，这样的需求非常普遍。 下面举例说明。函数 forward_value 是一个泛型函数，它将一个参数传递给另一个函数 process_value。 forward_value 的定义为： 123456template &lt;typename T&gt; void forward_value(const T&amp; val) { process_value(val); } template &lt;typename T&gt; void forward_value(T&amp; val) { process_value(val); } 函数 forward_value 为每一个参数必须重载两种类型，T&amp; 和 const T&amp;，否则，下面四种不同类型参数的调用中就不能同时满足 : 12345int a = 0; const int &amp;b = 1; forward_value(a); // int&amp; forward_value(b); // const int&amp; forward_value(2); // int&amp; 对于一个参数就要重载两次，也就是函数重载的次数和参数的个数是一个正比的关系。这个函数的定义次数对于程序员来说，是非常低效的。我们看看右值引用如何帮助我们解决这个问题 : 123template &lt;typename T&gt; void forward_value(T&amp;&amp; val) { process_value(val); } 只需要定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数。四种不用类型参数的调用都能满足，参数的左右值属性和 const/non-cosnt 属性完全传递给目标函数 process_value。这个解决方案不是简洁优雅吗？ 12345int a = 0; const int &amp;b = 1; forward_value(a); // int&amp; forward_value(b); // const int&amp; forward_value(2); // int&amp;&amp; C++11 中定义的 T&amp;&amp; 的推导规则为： 右值实参为右值引用，左值实参仍然为左值引用。 一句话，就是参数的属性不变。这样也就完美的实现了参数的完整传递。 右值引用，表面上看只是增加了一个引用符号，但它对 C++ 软件设计和类库的设计有非常大的影响。它既能简化代码，又能提高程序运行效率。每一个 C++ 软件设计师和程序员都应该理解并能够应用它。我们在设计类的时候如果有动态申请的资源，也应该设计转移构造函数和转移拷贝函数。在设计类库时，还应该考虑 std::move 的使用场景并积极使用它。 指针","link":"/2020/05/31/c-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/"},{"title":"c++构造函数","text":"构造函数是一种特殊的成员函数，具有如下特点： 名字和类名相同，可以有参数，但是不能有返回值。 负责对对象进行初始化操作，生成对象时调用1次，此后不会被调用。 未定义构造函数，编译器会自动生成一个无参的构造函数，该函数没有任何操作。 构造函数可以被重载。 1234567891011121314151617181920212223242526class Node{private: /* data */ double key,value;public: Node(){}; Node(int k,int v=0); Node(double k,double v); double getKey() {return key;} ~Node(){};};Node::Node(int k,int v) { key = double(k);value = double(v);}Node::Node(double k,double v) { key=k;value=v;}int main() { Node n1; Node n2(1); Node n3(2,3); Node n4(1,2,3);//error，参数个数不匹配 Node *ptr4 = new Node(1.2,2.2); Node *ptr6 = new Node(1.2,2);//error,参数类型不匹配} 复制构造函数 复制构造函数只能有一个参数：同类对象的引用(type &amp; or const type &amp;) 未定义复制构造函数，编译器会自动生成一个复制构造函数。1234567891011121314151617181920class Node{private: /* data */ double key,value;public: Node(){}; Node(const Node&amp; node); ~Node(){};};Node::Node(const Node&amp; node) { key = node.key; value = node.value; cout &lt;&lt; \"copy constructor called\"&lt;&lt;endl;}int main() { Node n1; Node n4(n1); Node * ptr6 = new Node(n1);} 复制构造函数的使用 初始化对象时1Node n2(n1); 函数参数为对象时12345void func(Node node){};int main() { Node n4(3); func(n4);//调用复制构造函数} 函数返回值为对象时,如果没有调用，则是编译期做了优化12345678Node func1() { Node n(3); return n;}int main() { cout &lt;&lt; func1().getKey()&lt;&lt;endl; //如果没有调用复制构造函数，是编译器做了优化，不再产生临时对象} 类型转换构造函数 实现类型的自动转换 只有一个参数 转换构造函数会建立一个临时对象 12345678910111213141516171819class Node{private: /* data */ double key,value;public: Node(){}; Node(int k);//类型转换构造函数 double getKey() {return key;} ~Node(){};};Node::Node(int k) { key = double(k);value = 0; cout &lt;&lt; \"typeTrans constructor called\"&lt;&lt;endl;}int main(){ Node n5; n5 = 6;//类型转换}","link":"/2020/05/31/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"RAFT实现之log Replication","text":"实现要点1.AppendEntriesRPC接收者（follower，candidate）除了实现图中的1~5，还需要注意以下几点： 收到更大的term，或者candidate收到leader的心跳包，转为follower 1234567 //收到更高的term，更新term,转为follwer if leaderTerm &gt; rf.currentTerm { rf.convertToFollwer(leaderTerm)//候选人收到leader的心跳包，转为follwer } else if leaderTerm == rf.currentTerm &amp;&amp; rf.state == candidate { rf.convertToFollwer(leaderTerm) } 如果follower日志和leader的冲突，需要将冲突信息（conflictTerm、conflictIndex）返回给leader，这里是论文中的方法优化版，可以让leader迅速定位冲突的日志位置。 1234567891011121314151617181920212223 if prevLogIndex &gt;= len(rf.log) {//如果prevLogIndex处的日志不存在 reply.Success = false reply.ConflictIndex = len(rf.log) reply.ConflictTerm = -1 return //如果prevLogIndex的日志存在，但是term不一致 } else if rf.log[prevLogIndex].Term != prevLogTerm { reply.Success = false reply.ConflictTerm = rf.log[prevLogIndex].Term flag := false //返回冲突term的最开始的index for i:=prevLogIndex-1;i&gt;=0;i-- { if rf.log[i].Term != reply.ConflictTerm { reply.ConflictIndex = i+1 flag = true break; } } if !flag { reply.ConflictIndex = 0 } return } 2.RPC回复处理发送者（leader）收到rpc调用的回复后，需要注意以下几点： 收到更大的term或过期的term，做相应的处理 12345678 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } //如果收到过期的term,丢弃 if rf.state!=leader || reply.Term &lt; rf.currentTerm { return false } 正确的更新nextIndex、matchIndex，根据rpc调用时的entries的长度来更新，而不是自己的log长度 12rf.nextIndex[serverid] = args.PrevLogIndex+len(args.Entries)+1rf.matchIndex[serverid] = args.PrevLogIndex+len(args.Entries) 要迅速定位和follower的冲突日志的index，以一个term为单位来检查是否有冲突，而不是一个个entry来找 12345678910111213141516 //加速检查 firstConflict := reply.ConflictIndex if reply.ConflictTerm != -1 { flag := false for i,entry := range rf.log { if entry.Term == reply.ConflictTerm { if !flag { flag = true } firstConflict = i } else if flag { break } } } rf.nextIndex[serverid] = firstConflict 3.提交状态机一个守护进程周期性的检查能否提交状态机 123456789101112131415161718192021func (rf *Raft) PeriodicApplyMsg() { for { //检查commitIndex &gt; lastApplied //大于则增加lastApplied,并提交到状态机 rf.mu.Lock() var applyLogs []entry commitIndex := rf.commitIndex lastApply := rf.lastApplied if commitIndex &gt; lastApply { applyLogs = rf.log[lastApply+1:commitIndex+1] rf.lastApplied = commitIndex } rf.mu.Unlock() if len(applyLogs) &gt; 0 { for i,entry := range applyLogs { rf.applyCh &lt;- ApplyMsg{true,entry.Command,lastApply+1+i} } } time.Sleep(10*time.Millisecond) }} 这里需要注意两点： 1. 提交的时候不要给applyCh加锁，因为上锁会阻塞channel（？？？理由待验证） 2. 为了效率，要一次性把能提交的一块提交。 测试通过","link":"/2020/05/31/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Blog-Replication/"},{"title":"c++ static","text":"静态成员变量 成员变量前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局变量 使用静态变量必须在类外部初始化 123456789101112class testStatic{private: int m;public: static int n;};//外部初始化int testStatic::n = 0;int main() { cout&lt;&lt;sizeof(testStatic)&lt;&lt;endl;//4} 如何访问? 类名::成员变量名1testStatic::n 对象名.成员变量名12testStatic t1;t1.n; 指针-&gt;成员变量名12testStatic *ptr = t2;t2-&gt;n; 引用-&gt;成员变量名12testStatic &amp;ptr = t2;t2-&gt;n; 静态成员函数 成员函数前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局函数 不能访问非静态成员变量 不能调用非静态成员函数1234567891011class testStatic{private: int m;public: static int n; static void prinfs(){ cout&lt;&lt;n&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl;//error,不能访问非static成员变量 }}; 静态成员函数访问方法和静态成员变量一致。","link":"/2020/06/01/c-static/"},{"title":"c++ this","text":"this指针指向成员函数所作用的对象 静态成员函数不能使用this指针 因为静态成员函数不属于某个对象 123456789101112131415class testThis{ int n;public: void hello() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } void printn() { cout &lt;&lt; this-&gt;n &lt;&lt; endl; }};int main(){ testThis *ptr = NULL; ptr-&gt;hello();//ok,函数体为用到this指针 ptr-&gt;printn();//error,this指针为空}","link":"/2020/06/01/c-this/"},{"title":"c++析构函数","text":"析构函数在对象消亡时会被自动调用，用于释放内存空间等操作 析构函数与类名相同 没有参数和返回值 不能重载，只能有一个析构函数 没有定义析构函数，编译期会自动生成析构函数，该析构函数不做任何事 123456789101112131415161718class String{private: char *p;public: String() { p = new char[10]; }; ~String();};String::~String(){ delete[] p; cout &lt;&lt; \"destructor called\"&lt;&lt;endl;} 一个对象生命周期结束时会调用析构函数； 如果是对象数组，则数组中的每个对象的析构函数都会被调用; 如果是指针类型，需要通过delete来调用析构函数123456int main() { String str; String strlist[3]; String * ptr = new String; delete ptr;} 输出12345destructor called //strdestructor called //strlist[0]destructor called //strlist[1]destructor called //strlist[2]destructor called //*ptr 同一作用域内，先构造的对象后析构 123456789101112131415161718192021222324252627282930313233343536class String{private: int id;public: String(){}; String(int i); String(char ch); ~String();};String::~String(){ cout &lt;&lt; id &lt;&lt; \" destructor called\" &lt;&lt; endl;}String::String(int i){ id = i; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;};String::String(char ch){ id = ch - '0'; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;}int main(){ String str1(1); str1 = '6'; if (1) { String str2(2); } String str3(3);} 输出123456781 constructor called6 constructor called 6 destructor called //赋值是生成的临时变量2 constructor called2 destructor called3 constructor called3 destructor called6 destructor called","link":"/2020/06/01/c-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"title":"c++重载","text":"运算符重载 c++中预定义的运算符最初只能对基本的数据类型进行操作。 对已有的运算符赋予多重的含义。 使同一运算符作用于不同类型的数据时，有不同类型的行为。 目的扩展C++中提供的运算符的适用范围, 以用于类所表示的抽象数据类型。 运算符重载需要注意： 运算符重载不改变运算符的优先级 以下运算符不能被重载： “.”, “.*”, “::”, “?:”, sizeof 重载运算符(), [ ], -&gt;或者赋值运算符=时, 重载函数必须声明为类的成员函数 原理在程序编译时: 把含运算符的表达式 –&gt; 对运算符函数的调用 把运算符的操作数 –&gt; 运算符函数的参数 运算符被多次重载时, 根据实参的类型决定调用哪个运算符函数 重载为普通函数 参数个数为运算符目数 12345678910111213141516171819class complex{public: double r, i; complex(double a, double b) { a = r; b = i; }};complex operator+ (const complex&amp; a,const complex&amp; b) { return complex(a.r+b.r,a.i+b.i);}int main(){ complex a(1,1),b(2,1),c; c=a+b;//==&gt;c=operator+(a,b)} 重载为成员函数 参数个数为运算符目数减一 1234567891011121314151617181920class complex{public: double r, i; complex(){}; complex(double a, double b) { a = r; b = i; } //重载为成员函数 complex operator-(const complex&amp; b) { return complex(r-b.r,i-b.i); }};int main(){ complex a(1,1),b(2,1),c; c = a-b;//==&gt;c = a.operator-(b)} 赋值运算符重载正常情况下，赋值运算符可作用于自定义的数据类型上，比如定义了一个字符串类： 12345678910111213class myString{ char *str; int size;public: myString() : str(NULL),size(0) {} myString(const char *s); myString(const myString &amp;s); void printaddr() { cout &lt;&lt; (void *)str &lt;&lt; endl; } void printstring() { cout &lt;&lt; str &lt;&lt; endl; } int length() {return size;} ~myString() { if(str) delete [] str; }}; 如果使用=来进行赋值操作会发生什么呢? 12345678910int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce70} 所以原始的=赋值只会简单把成员变量的值变得相同，这种赋值就是浅拷贝，对于上面这个例子，仅仅是将两个指针变得指向同一份数据。这种浅拷贝的方式会有如下问题： 指针原来指向的数据没有被释放，变成垃圾内存。 如果一个指针提前释放内存中的数据，那么另一个指针就会变成野指针。 指针指向内存地址会被释放两次，可能会出现内存错误。 为了避免上述问题，我们需要另一种赋值方式-深拷贝。深拷贝是将指针指向的值拷贝过去，而不是指针本身。为了在自己定义的类中实现这个目标，需要我们定义赋值运算符重载函数 1234567891011121314151617181920212223242526272829myString &amp;myString::operator=(const myString &amp;s){ if (str == s.str) return *this; if (s.str) { if (size&lt;s.size) if(str) delete[] str; str = new char[s.size + 1]; strcpy(str, s.str); size = strlen(s.str); } else { str = NULL; size = 0; } return *this;}int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90} 这里将返回值定义为myString&amp;是为了能实现连续赋值，考虑以下情形： 1234myString str1(\"abc\"),str2(\"cde\"),str3(\"efg\");(str1 = str2) = str3;//(str1.opreator=(str2)).opreator=(str3)str1.printstring();//efg 第一次赋值为str1=str2,其返回值我们暂记作xxx;第二次赋值为xxx=str3;这段代码的目的是将str3的值赋给str1，如果返回值不为引用myString&amp;，那么xxx就是一个临时产生对象，不会对str1有任何影象。 []运算符重载 []运算重载需要注意返回值的类型，应当返回引用类型，这样才可以去修改数组指定下标的值。 12345678910char&amp; myString::operator[](int i) { return str[i];}int main(){ myString str1(\"abc\"); cout&lt;&lt;str1[1]&lt;&lt;endl;//a str1[0]='9'; str1.printstring();//abc} &lt;&lt;和&gt;&gt;运算符重载运算符&lt;&lt;和运算符&gt;&gt;原始含义是二进制算数左移和二进制算术右移，在ostream类和istream类中将他们重载为输出流和输入流。 12345678910ostream &amp; ostream::operator&lt;&lt;(int n){ …… //输出n的代码 return * this;}istream &amp; istream::operator&gt;&gt;(int&amp; n){ …… //输入s的代码 return * this;} 可以看到返回值均为ostream和istream类的引用，这里为了能实现输出/输入拼接。 1cout&lt;&lt;\"hello\"&lt;&lt;\"world\"; 那么如果想用ostream或istream对我们自定义的myString类执行输入输出是否可行呢？ 12myString str(\"hello\");cout &lt;&lt;str&lt;&lt;endl;//error 显然不行，因为ostream类中并没有将&lt;&lt;重载为适合myString类的输出函数，所以需要我们自己重载&lt;&lt;运算符，显然我们无法在ostream的成员函数中重载，因此我们只能重载一个普通的全局函数。为了方便访问对象中的私有数据，声明为友元函数。 1234567891011121314151617181920class myString{ char *str; int size;public: ... friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s); friend istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s);};ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s) { out&lt;&lt;s.str; return out;}istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s) { if(!s.str) { s.str = new char[20]; } in &gt;&gt;s.str; return in;} 这样便可以使用cin和cout来自输入输出了 123myString str;cin &gt;&gt; str;cout&lt;&lt;str&lt;&lt;endl; ++和–运算符重载++和–运算符有前置/后置之分，即++i和i++是有区别的。 前置是一元运算符：++i/–i 重载为成员函数: T &amp; operator++(); T &amp; operator–(); 重载为全局函数： T &amp; operator++(T &amp;); T &amp; operator–(T &amp;); 后置运算符作为二元运算符重载:i++/i– 多写一个参数, 仅为了区分前后置，具体无意义 重载为成员函数: T operator++(int); T operator–(int); 重载为全局函数: T operator++(T &amp;, int); T operator–(T &amp;, int);","link":"/2020/06/03/c-%E9%87%8D%E8%BD%BD/"},{"title":"c++继承“","text":"继承和派生是一件事，指的是子类/派生类通过某种方式继承了父类/基类的成员变量和成员函数。 派生类拥有基类的全部成员函数和成员变量。 派生类中可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 在派生类的各个成员函数中，不能访问基类中的private成员。 c++中有三种继承方式，分别为public继承、private继承和protected继承。对于基类base:123456789101112131415161718class base{private: int priv; void priFunc() {}protected: int pro; void proFunc() {}public: int pub; void pubFunc() {} base() { cout &lt;&lt; \"base constructor called\" &lt;&lt; endl; }}; public继承 public继承表达的是”is”关系，即子类必须是父类，例如”男人“可以public继承”人“，因为”男人“is”人” 12345678910111213class drive1 : public base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive1() { cout &lt;&lt; \"drive1 constructor called!\"&lt;&lt;endl; }}; public继承会保留基类非私有成员的可见性 1234567drive1 d1;// d1.pri;//error// d1.priFunc();//error// d1.pro;//error// d1.proFunc();//errord1.pub;d1.pubFunc(); public继承的赋值兼容规则1234class base { };class derived : public base { };base b;derived d; 派生类的对象可以赋值给基类对象 b = d; 派生类对象可以初始化基类引用 base &amp; br = d; 派生类对象的地址可以赋值给基类指针 base * pb = &amp; d; 如果派生方式是 private或protected，则上述三条不可行。 private继承 private继承表达的是”根据某物实现出”的关系，即子类通过父类可实现自己成员函数，例如圆形可通过二维点坐标实现自己的一系列方法。 12345678910111213class drive2 : private base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive2() { cout &lt;&lt; \"drive2 constructor called!\"&lt;&lt;endl; }}; private继承会保留基类非私有成员的可见性全部变为private 123drive2 d2;// d2.pub;//error// d2.pubFunc();//error protected继承protected继承会保留基类非私有成员的可见性全部变为protected 123456789101112131415class drive3 : protected base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive3() { cout &lt;&lt; \"drive3 constructor called!\"&lt;&lt;endl; }};drive3 d3;// d3.pubFunc();//error 派生类的构造 派生类构造的时候总是先构造基类，即执行基类的构造函数，然后再执行派生类的构造函数。 12345678910drive1 d1;drive2 d2;drive3 d3;---base constructor calleddrive1 constructor called!base constructor calleddrive2 constructor called!base constructor calleddrive3 constructor called! 调用基类构造函数的两种方式 显式方式: 派生类的构造函数中基类的构造函数提供参数derived::derived(arg_derived-list):base(arg_base-list) 隐式方式: 派生类的构造函数中, 省略基类构造函数时 派生类的构造函数, 自动调用基类的默认构造函数 派生类的析构 派生类析构的时候总是先执行派生类的析构函数，然后再执行基类的析构函数。 123456drive3 d3;---base constructor calleddrive3 constructor called!drive3 destructor calledbase destructor called","link":"/2020/06/06/c-%E7%BB%A7%E6%89%BF/"},{"title":"c++多态与虚函数","text":"在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。 多态派生类的指针可以赋给基类指针。通过基类指针调用基类和派生类中的同名虚函数时: 若该指针指向一个基类的对象，那么被调用是基类的虚函数； 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class base{public: virtual void baseFunc1() { cout &lt;&lt; \"base1\" &lt;&lt; endl; }};class drive1 : public base{public: virtual void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; }};int main(){ base A;drive1 B;base *ptr; ptr = &amp;A; ptr-&gt;baseFunc1();//base1 ptr = &amp;B; ptr-&gt;baseFunc1();//drive1} 派生类的对象可以赋给基类引用,通过基类引用调用基类和派生类中的同名虚函数时: 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数； 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。123drive1 B;base &amp;ptr2 = B;ptr2.baseFunc1();//drive1 非构造和非析构函数调用虚函数也是多态 12345678910111213141516171819202122class base{public: base() {baseFunc1();}//没有多态 virtual void baseFunc1() { cout &lt;&lt; \"base1\" &lt;&lt; endl; } void func() {baseFunc1();}//多态};class drive1 : public base{public: //不加virtual也是虚函数，只要基类中是虚函数且同名同参数 void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl;}};int main(){ base A;drive1 B;base *ptr; ptr = &amp;A; ptr-&gt;func(); ptr = &amp;B; ptr-&gt;func();} 为什么构造函数和析构函数调用虚函数没有多态？ new一个派生类对象时，先调用基类的构造函数，此时派生类的成员没有初始化，如果此时去调用派生类的虚函数，那么结果会有问题，无法保证正确性。所以只会用基类定义的虚函数。 delete一个派生类对象时,先调用派生类的析构函数，然后执行基类的析构函数，此时派生类的成员已经被释放掉了，如果此时去调用派生类的虚函数，那么同理，结果会有问题，无法保证正确性。所以只会用基类定义的虚函数。 虚函数在类的定义中，前面有virtual关键字的成员函数就是虚函数。virtual关键字只用在类定义里的函数声明中，写函数体时不用。 1234class base {virtual int vfunc() ;};int base::vfunc() { } 虚函数的实现原理C++给每个声明虚函数的类增加隐藏成员——虚函数表指针（vptr）。虚函数表指针指向一个函数地址数组，这个数组被成为虚函数表（vtable）。虚函数表中存储了类对象声明的虚函数的地址。虚函数表在编译期创建的。基类包含一个虚函数指针vptr1指向虚函数表vtable1，则派生类类将包含指向独立地址表的指针vptr2（不管有没有声明虚函数）指向虚函数表vtable2。 如果派生类提供了基类虚函数的新定义，vfpt2将保存新的函数地址（在vtable1基础上覆盖）; 如果派生类声明了新的虚函数，vtable2将添加该函数地址（在vtable1基础上添加）; 如果派生类仅仅是继承基类的虚函数，那么vtable2将保留原始函数地址（和vtable1保持一致）。 拥有虚函数的基类base123456789class base{ int a;public: base() { baseFunc1(); } //没有多态 virtual void baseFunc1() { cout &lt;&lt; \"base\" &lt;&lt; endl; } virtual void baseFunc2() { cout &lt;&lt; \"base\" &lt;&lt; endl; } void func() { baseFunc1(); } //多态}; 创建一个base类的实例A，则A在内存中的布局： 123A = {_vptr.base = 0x8201cb0 &lt;vtable for base+16&gt;, a = -20237175}(gdb) p sizeof(A)$3 = 16 可以看到A的第一个成员为虚函数表指针vptr，vptr并不是指向vtable的起始处，而是&lt;vtable for base+16&gt;处，即在vtable表头的16偏移处，为了方便我们打印0x8201cb0-16处的内存： 12345(gdb) x /100b 0x8201cb0-160x8201ca0 &lt;_ZTV4base&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201ca8 &lt;_ZTV4base+8&gt;: 0x78 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201cb0 &lt;_ZTV4base+16&gt;: 0x64 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201cb8 &lt;_ZTV4base+24&gt;: 0x9c 0x0f 0x00 0x08 0x00 0x00 0x00 0x00 ZTV4base是指vtable for base，即base类的虚函数表。可以看到base的vtable一共占36字节，具体内容如下： 1234567891011121314(gdb) x /w 0x8201ca00x8201ca0 &lt;_ZTV4base&gt;: 0x00000000(gdb) x /w 0x8201ca80x8201ca8 &lt;_ZTV4base+8&gt;: 0x08201d78(gdb) x 0x08201d780x8201d78 &lt;_ZTI4base&gt;: 0xff3ea7f8(gdb) x /w 0x8201cb00x8201cb0 &lt;_ZTV4base+16&gt;: 0x08000f64(gdb) x 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201cb80x8201cb8 &lt;_ZTV4base+24&gt;: 0x08000f9c(gdb) x 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855 这里ZTI4base指typeinfo of base类，即base的类型声明信息。 123456789 0x8201ca0--&gt;+-----------------------+ | 0 (top_offset) | +-----------------------+A --&gt; +----------+ 0x8201cb0 | ptr to typeinfo for A | | vptr |-----------&gt; +-----------------------+ +----------+ | ptr to base::Func1() | | a | +-----------------------+ +----------+ | ptr to base::Func2() | +-----------------------+ 继承base但没有声明/重写`虚函数的派生类drive1234class drive : public base{ int a;}; 创建一个drive类的实例B，则B在内存中的布局： 1234(gdb) p B$7 = {&lt;base&gt; = {_vptr.base = 0x8201c90 &lt;vtable for drive(gdb) p sizeof(B)$8 = 16 可以看到B的第一个成员为虚函数表指针vptr,注意到vptr和base没有声明或重写任何一个虚函数,但是编译期仍为drive生成了新的虚函数表。我们打印0x8201c90 123456789(gdb) x /100b 0x8201c90-160x8201c80 &lt;_ZTV5drive&gt;: 0x00 0x00 0x00 0x00 0x8201c88 &lt;_ZTV5drive+8&gt;: 0x60 0x1d 0x20 0x000x8201c90 &lt;_ZTV5drive+16&gt;: 0x64 0x0f 0x00 0x000x8201c98 &lt;_ZTV5drive+24&gt;: 0x9c 0x0f 0x00 0x000x8201ca0 &lt;_ZTV4base&gt;: 0x00 0x00 0x00 0x00 8201ca8 &lt;_ZTV4base+8&gt;: 0x78 0x1d 0x20 0xx000x8201cb0 &lt;_ZTV4base+16&gt;: 0x64 0x0f 0x00 0x000x8201cb8 &lt;_ZTV4base+24&gt;: 0x9c 0x0f 0x00 0x00 _ZTV5drive是指vtable for drive，即drive类的虚函数表。可且drive的虚函数表其后紧跟着base的虚函数表。drive的虚函数表具体内容如下： 1234567891011121314(gdb) x /w 0x8201c800x8201c80 &lt;_ZTV5drive&gt;: 0x00000000(gdb) x /w 0x8201c880x8201c88 &lt;_ZTV5drive+8&gt;: 0x08201d60(gdb) x /w 0x8201c900x8201c90 &lt;_ZTV5drive+16&gt;: 0x08000f64(gdb) x /w 0x8201c980x8201c98 &lt;_ZTV5drive+24&gt;: 0x08000f9c(gdb) x /w 0x08201d600x8201d60 &lt;_ZTI5drive&gt;: 0xff3eb438(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855 12345678910 0x8201c80--&gt;+-----------------------+ | 0 (top_offset) | +-----------------------+B --&gt; +----------+ 0x8201c90 | ptr to typeinfo for B | | vptr |-----------&gt; +-----------------------+ +----------+ | ptr to base::Func1() | | A::a | +-----------------------+ +----------+ | ptr to base::Func2() | | B::a | +-----------------------+ +----------+ 继承base且重写base类虚函数的派生类drive112345678class drive1 : public base{ int b;public: //不加virtual也是虚函数，只要基类中是虚函数且同名同参数 void baseFunc2() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; } virtual void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; }}; 创建一个drive类的实例B，则B在内存中的布局： 1234(gdb) p C$11 = {&lt;base&gt; = {_vptr.base = 0x8201c70 &lt;vtable for drive1+16&gt;, a = 136321944}, b = 0}(gdb) p sizeof(C)$12 = 16 可以看到C的第一个成员为虚函数表指针vptr,注意到vptr和base的vptr不一样。这说明编译器给drive1生产了新的虚函数表,0x8201c70-16处的内存： 123456(gdb) x /100b 0x8201c70-160x8201c60 &lt;_ZTV6drive1&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201c68 &lt;_ZTV6drive1+8&gt;: 0x48 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201c70 &lt;_ZTV6drive1+16&gt;: 0x0c 0x10 0x00 0x08 0x00 0x00 0x00 0x000x8201c78 &lt;_ZTV6drive1+24&gt;: 0xd4 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c80 &lt;_ZTV5drive&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 _ZTV6drive1是指vtable for drive1，即drive1类的虚函数表。drive1的虚函数表具体内容如下： 1234567891011121314(gdb) x /w 0x8201c600x8201c60 &lt;_ZTV6drive1&gt;: 0x00000000(gdb) x /w 0x8201c680x8201c68 &lt;_ZTV6drive1+8&gt;: 0x08201d48(gdb) x /w 0x08201d480x8201d48 &lt;_ZTI6drive1&gt;: 0xff3eb438(gdb) x /w 0x8201c700x8201c70 &lt;_ZTV6drive1+16&gt;: 0x0800100c(gdb) x /w 0x0800100c0x800100c &lt;drive1::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201c780x8201c78 &lt;_ZTV6drive1+24&gt;: 0x08000fd4(gdb) x /w 0x08000fd40x8000fd4 &lt;drive1::Func2()&gt;: 0xe5894855 12345678910 0x8201c60--&gt;+------------------------+ | 0 (top_offset) | +------------------------+C --&gt; +----------+ 0x8201c70 | ptr to typeinfo for C | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | A::a | +------------------------+ +----------+ | ptr to drive1::Func2() | | C::b | +------------------------+ +----------+ 可以看到drive1的虚函数表中的Func1()和Func2()的函数地址被覆盖为drive1定义的函数。 继承base且声明新的虚函数的派生类drive2123456class drive2 : public base{ int b;public: virtual void Func3() {}}; 创建一个drive类的实例B，则B在内存中的布局： 123$3 = {&lt;base&gt; = {_vptr.base = 0x8201c48 &lt;vtable for drive2+16&gt;, a = 134221601}, b = 0}(gdb) p sizeof(D)$4 = 16 可以看到D的第一个成员为虚函数表指针vptr,注意到vptr和base的vptr不一样。这说明编译器给drive2生产了新的虚函数表,0x8201c48-16处的内存： 1234567(gdb) x /100b 0x8201c48-160x8201c38 &lt;_ZTV6drive2&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201c40 &lt;_ZTV6drive2+8&gt;: 0x30 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201c48 &lt;_ZTV6drive2+16&gt;: 0x64 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c50 &lt;_ZTV6drive2+24&gt;: 0x9c 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c58 &lt;_ZTV6drive2+32&gt;: 0x44 0x10 0x00 0x08 0x00 0x00 0x00 0x000x8201c60 &lt;_ZTV6drive1&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 drive2的虚函数表具体内容如下： 123456789101112131415161718(gdb) x /w 0x8201c380x8201c38 &lt;_ZTV6drive2&gt;: 0x00000000(gdb) x /w 0x8201c400x8201c40 &lt;_ZTV6drive2+8&gt;: 0x08201d30(gdb) x /w 0x08201d300x8201d30 &lt;_ZTI6drive2&gt;: 0xff3eb438(gdb) x /w 0x8201c480x8201c48 &lt;_ZTV6drive2+16&gt;: 0x08000f64(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201c500x8201c50 &lt;_ZTV6drive2+24&gt;: 0x08000f9c(gdb) x /w 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855(gdb) x /w 0x8201c580x8201c58 &lt;_ZTV6drive2+32&gt;: 0x08001044(gdb) x /w 0x080010440x8001044 &lt;drive2::Func3()&gt;: 0xe5894855 12345678910111213141516171819 0x8201c38--&gt;+------------------------+ | 0 (top_offset) | +------------------------+D --&gt; +----------+ 0x8201c48 | ptr to typeinfo for D | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | A::a | +------------------------+ +----------+ | ptr to base::Func2() | | D::b | +------------------------+ +----------+ | ptr to drive2::Func3() | +------------------------+ ``` 可以看到drive1的虚函数表中的Func1()和Func2()的函数地址被#### 继承drive和drive1的派生类moreDrive```c++class moreDrive : public drive,drive1{ int b;}; 创建一个moreDrive类的实例E，则E在内存中的布局： 1234(gdb) p E$5 = {&lt;drive&gt; = {&lt;base&gt; = {_vptr.base = 0x8201c08 &lt;vtable for moreDrive+16&gt;, a = 65535}, a = 1}, &lt;drive1&gt; = {&lt;base&gt; = {_vptr.base = 0x8201c28 &lt;vtable for moreDrive+48&gt;, a = 134221623}, b = 0}, b = 2}(gdb) p sizeof(E)$7 = 40 可以看到有2个虚函数表指针，但是这两个指针指向的是同一个虚数表，只不过这两个指针相对表头的偏移不一样。0x8201c08-16处的内存： 12345(gdb) x /100w 0x8201c08-160x8201bf8 &lt;_ZTV9moreDrive&gt;: 0x00000000 0x00000000 0x08201cf8 0x000000000x8201c08 &lt;_ZTV9moreDrive+16&gt;: 0x08000f64 0x00000000 0x08000f9c 0x000000000x8201c18 &lt;_ZTV9moreDrive+32&gt;: 0xfffffff0 0xffffffff 0x08201cf8 0x000000000x8201c28 &lt;_ZTV9moreDrive+48&gt;: 0x0800100c 0x00000000 0x08000fd4 0x00000000 moreDrive的虚函数表具体内容如下： 123456789101112(gdb) x /w 0x08201cf80x8201cf8 &lt;_ZTI9moreDrive&gt;: 0xff3eb4f8(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855(gdb) p /d 0xfffffff0$8 = -16(gdb) x /w 0x0800100c0x800100c &lt;drive1::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000fd40x8000fd4 &lt;drive1::Func2()&gt;: 0xe5894855 12345678910111213141516171819202122232425 0x8201bf8--&gt;+------------------------+ | 0 (top_offset) | +------------------------+E --&gt; +----------+ 0x8201c08 | ptr to typeinfo for E | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | base::a | +------------------------+ +----------+ | ptr to base::Func2() | | drive::a | +------------------------+ +----------+ | -16 (top_offset) | | vptr |-- +------------------------+ +----------+ | 0x8201c28 | ptr to typeinfo for E | | base::a | ----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | drive1::b| +------------------------+ +----------+ | ptr to drive1::Func2() | | b | +------------------------+ +----------+``` #### 继承drive1和drive2的派生类moreDrive1```c++class moreDrive1 : public drive1,drive2{ int b;}; 创建一个moreDrive1类的实例F，则F在内存中的布局： 12345(gdb) p F$1 = {&lt;drive1&gt; = {&lt;base&gt; = {_vptr.base = 0x8201bc0 &lt;vtable for moreDrive1+16&gt;, a = 0}, b = 0}, &lt;drive2&gt; = {&lt;base&gt; = {_vptr.base = 0x8201be0 &lt;vtable for moreDrive1+48&gt;, a = 134221120}, b = 0}, b = -75408}(gdb) p sizeof(F)$2 = 40 可以看到有2个虚函数表指针，指向的是同一个虚数表，只不过这两个指针相对表头的偏移不一样。0x8201bc0-16处的内存： 123456(gdb) x /100w 0x8201bc0-160x8201bb0 &lt;_ZTV10moreDrive1&gt;: 0x00000000 0x00000000 0x08201cc0 0x000000000x8201bc0 &lt;_ZTV10moreDrive1+16&gt;: 0x0800100c 0x00000000 0x08000fd4 0x000000000x8201bd0 &lt;_ZTV10moreDrive1+32&gt;: 0xfffffff0 0xffffffff 0x08201cc0 0x000000000x8201be0 &lt;_ZTV10moreDrive1+48&gt;: 0x08000f64 0x00000000 0x08000f9c 0x000000000x8201bf0 &lt;_ZTV10moreDrive1+64&gt;: 0x08001044 0x00000000 0x00000000 0x00000000 123456789101112131415161718192021222324252627 0x8201bb0--&gt;+------------------------+ | 0 (top_offset) | +------------------------+F --&gt; +----------+ 0x8201bc0 | ptr to typeinfo for F | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | base::a | +------------------------+ +----------+ | ptr to drive1::Func2() | | drive1::b| +------------------------+ +----------+ | -16 (top_offset) | | vptr |-- +------------------------+ +----------+ | 0x8201be0 | ptr to typeinfo for F | | base::a | ----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | drive2::b| +------------------------+ +----------+ | ptr to base::Func2() | | b | +------------------------+ +----------+ | ptr to drive2::Func3() | +------------------------+``` #### 更进一步#### 继承drive, drive1和drive2的派生类moreDrive2```c++class moreDrive2 : public drive,drive1,drive2{ int c;}; 123456(gdb) p G$1 = {&lt;drive&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b10 &lt;vtable for moreDrive2+16&gt;, a = 134222733}, a = 0}, &lt;drive1&gt; = {&lt;base&gt; = { _vptr.base = 0x8201b30 &lt;vtable for moreDrive2+48&gt;, a = 0}, b = 0}, &lt;drive2&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b50 &lt;vtable for moreDrive2+80&gt;, a = 134221472}, b = 0}, c = -75456}(gdb) p sizeof(G)$2 = 56 可以看到有3个虚函数表指针，指向的是同一个虚数表。0x8201b10-16处的内存： 12345678(gdb) x /100w 0x8201b10-160x8201b00 &lt;_ZTV10moreDrive2&gt;: 0x00000000 0x00000000 0x08201c78 0x000000000x8201b10 &lt;_ZTV10moreDrive2+16&gt;: 0x080010d8 0x00000000 0x08001110 0x000000000x8201b20 &lt;_ZTV10moreDrive2+32&gt;: 0xfffffff0 0xffffffff 0x08201c78 0x000000000x8201b30 &lt;_ZTV10moreDrive2+48&gt;: 0x08001180 0x00000000 0x08001148 0x000000000x8201b40 &lt;_ZTV10moreDrive2+64&gt;: 0xffffffe0 0xffffffff 0x08201c78 0x000000000x8201b50 &lt;_ZTV10moreDrive2+80&gt;: 0x080010d8 0x00000000 0x08001110 0x000000000x8201b60 &lt;_ZTV10moreDrive2+96&gt;: 0x080011b8 0x00000000 123456789101112131415161718192021222324252627 0x8201b00--&gt;+------------------------+ | 0 (top_offset) | +------------------------+G --&gt; +----------+ 0x8201b10 | ptr to typeinfo for G | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | base::a | +------------------------+ +----------+ | ptr to base::Func2() | | drive::a | +------------------------+ +----------+ | -16 (top_offset) | | vptr |-- +------------------------+ +----------+ | 0x8201b30 | ptr to typeinfo for G | | base::a | ----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | drive1::b| +------------------------+ +----------+ | ptr to drive1::Func2() | | vptr |-- +------------------------+ +----------+ | | -32 (top_offset) | | base::a | |0x8201b50 +------------------------+ +----------+ ----------&gt; | ptr to typeinfo for G | | drive2::b| +------------------------+ +----------+ | ptr to base::Func1() | | c | +------------------------+ +----------+ | ptr to base::Func2() | +------------------------+ | ptr to drive2::Func3() | +------------------------+ 如果我们将继承的父类换一下顺序呢？ 1234class moreDrive2 : public drive1,drive2,drive{ int c;}; 1234(gdb) p /x$2 = {&lt;drive1&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b10 &lt;vtable for moreDrive2+16&gt;, a = 0x800138d}, b = 0x0}, &lt;drive2&gt; = {&lt;base&gt; = { _vptr.base = 0x8201b30 &lt;vtable for moreDrive2+48&gt;, a = 0x0}, b = 0x0}, &lt;drive&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b58 &lt;vtable for moreDrive2+88&gt;, a = 0x8000ea0}, a = 0x0}, c = 0xfffed940} 12345678(gdb) x /100w 0x8201b10-160x8201b00 &lt;_ZTV10moreDrive2&gt;: 0x00000000 0x00000000 0x08201c78 0x000000000x8201b10 &lt;_ZTV10moreDrive2+16&gt;: 0x08001180 0x00000000 0x08001148 0x000000000x8201b20 &lt;_ZTV10moreDrive2+32&gt;: 0xfffffff0 0xffffffff 0x08201c78 0x000000000x8201b30 &lt;_ZTV10moreDrive2+48&gt;: 0x080010d8 0x00000000 0x08001110 0x000000000x8201b40 &lt;_ZTV10moreDrive2+64&gt;: 0x080011b8 0x00000000 0xffffffe0 0xffffffff0x8201b50 &lt;_ZTV10moreDrive2+80&gt;: 0x08201c78 0x00000000 0x080010d8 0x000000000x8201b60 &lt;_ZTV10moreDrive2+96&gt;: 0x08001110 0x00000000 123456789101112131415161718192021222324252627 0x8201b00--&gt;+------------------------+ | 0 (top_offset) | +------------------------+G --&gt; +----------+ 0x8201b10 | ptr to typeinfo for G | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | base::a | +------------------------+ +----------+ | ptr to drive1::Func2() | | drive1::b| +------------------------+ +----------+ | -16 (top_offset) | | vptr |-- +------------------------+ +----------+ | 0x8201b30 | ptr to typeinfo for G | | base::a | ----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | drive2::b| +------------------------+ +----------+ | ptr to base::Func2() | | vptr |-- +------------------------+ +----------+ | | ptr to drive2::Func3() | | base::a | | +------------------------+ +----------+ | | -32 (top_offset) | | drive::a | | +------------------------+ +----------+ | 0x8201b58 | ptr to typeinfo for G | | c | -----------&gt;+------------------------+ +----------+ | ptr to base::Func1() | +------------------------+ | ptr to base::Func2() | +------------------------+ 可以看到虚函数表中各个类的成员函数的顺序和声明类的时候父类顺序是一致的。 1234567class moreDrive2 : public drive1, drive2, drive{ int c;public: virtual void Func4() {}}; 123456(gdb) p G$1 = {&lt;drive1&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b08 &lt;vtable for moreDrive2+16&gt;, a = 134222781}, b = 0}, &lt;drive2&gt; = {&lt;base&gt; = { _vptr.base = 0x8201b30 &lt;vtable for moreDrive2+56&gt;, a = 0}, b = 0}, &lt;drive&gt; = {&lt;base&gt; = {_vptr.base = 0x8201b58 &lt;vtable for moreDrive2+96&gt;, a = 134221504}, a = 0}, c = -75472}(gdb) p sizeof(G)$2 = 56 12345678(gdb) x /100w 0x8201b08-160x8201af8 &lt;_ZTV10moreDrive2&gt;: 0x00000000 0x00000000 0x08201c78 0x000000000x8201b08 &lt;_ZTV10moreDrive2+16&gt;: 0x080011a0 0x00000000 0x08001168 0x000000000x8201b18 &lt;_ZTV10moreDrive2+32&gt;: 0x080011e4 0x00000000 0xfffffff0 0xffffffff0x8201b28 &lt;_ZTV10moreDrive2+48&gt;: 0x08201c78 0x00000000 0x080010f8 0x000000000x8201b38 &lt;_ZTV10moreDrive2+64&gt;: 0x08001130 0x00000000 0x080011d8 0x000000000x8201b48 &lt;_ZTV10moreDrive2+80&gt;: 0xffffffe0 0xffffffff 0x08201c78 0x000000000x8201b58 &lt;_ZTV10moreDrive2+96&gt;: 0x080010f8 0x00000000 0x08001130 0x00000000 1234567891011121314151617181920212223242526272829 0x8201af8--&gt;+----------------------------+ | 0 (top_offset) | +----------------------------+G --&gt; +----------+ 0x8201b08 | ptr to typeinfo for G | | vptr |-----------&gt; +----------------------------+ +----------+ | ptr to drive1::Func1() | | base::a | +----------------------------+ +----------+ | ptr to drive1::Func2() | | drive1::b| +----------------------------+ +----------+ | ptr to moredrive2::Func4() | | vptr |-- +----------------------------+ +----------+ | | -16 (top_offset) | | base::a | | +----------------------------+ +----------+ | 0x8201b30 | ptr to typeinfo for G | | drive2::b| ----------&gt; +----------------------------+ +----------+ | ptr to base::Func1() | | vptr |-- +----------------------------+ +----------+ | | ptr to base::Func2() | | base::a | | +----------------------------+ +----------+ | | ptr to drive2::Func3() | | drive::a | | +----------------------------+ +----------+ | | -32 (top_offset) | | c | | +----------------------------+ +----------+ | 0x8201b58 | ptr to typeinfo for G | -----------&gt;+----------------------------+ | ptr to base::Func1() | +----------------------------+ | ptr to base::Func2() | +----------------------------+ 可以看到派生类新定义的虚函数会放在第一个基类的虚函数后面。 问题top_offset有何用处？ 使用虚函数需要注意 构造函数可以是虚函数吗?不可以。 虚函数表指针vptr是调用构造函数时创建的。 如果构造函数是虚的，那么调用构造函数时需要通过vptr来访问vtable。 所以构造函数显然不能为虚函数。 析构函数可以是虚函数吗?可以。 如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 如果一个类有可能会被其它类所继承， 就应该声明虚析构函数。否则析构时派生类的成员变量会被遗漏。 静态成员函数可以是虚函数吗? 不可以。 static成员函数不属于任何类对象，所以即使给此函数加上virutal也是没有任何意义。 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。 友元函数可以是虚函数吗?不可以。 友元函数不能继承。 虚函数可以被内联吗？ 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 纯虚函数和抽象类纯虚函数: 没有函数体的虚函数 1234class A { public: virtual void Print( ) = 0 ; //纯虚函数}; 抽象类：包含纯虚函数的类 只能作为基类来派生新类使用 不能创建抽象类的对象 抽象类的指针和引用–&gt;由抽象类派生出来的类的对象 A a; // 错, A 是抽象类, 不能创建对象 A * pa; // ok, 可以定义抽象类的指针和引用 pa = new A; //错误, A 是抽象类, 不能创建对象 在构造函数/析构函数内部不能调用纯虚函数，为什么？","link":"/2020/06/06/c-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"},{"title":"密码学-分组密码","text":"ECB模式：electronic codebook mode 电子密码本模式 CBC模式：cipher block chaining mode 分组链接模式 CFB模式：cipher feedback mode 密文反馈模式 OFB模式：output feedback mode 输出反馈模式 CTR模式：counter mode 计数器模式 ECB模式 明文分组加密后直接输出为密文分组。 ) ECB模式的攻击： 明文分组相同–&gt;密文分组相同，这样明文的分布特征容易被推测。 如果改变了密文分组的顺序，那么相应的明文分组顺序就会改变。这样攻击者就可以直接操控明文。 CBC模式CBC模式中，明文分组和前一个密文分组异或后，然后再进行加密。其中IV是初始化向量，每次加密随机产生。 CBC模式的攻击：攻击初始向量IV 将IV的任意bit翻转都会导致相应的明文分组的比特翻转。 如果翻转密文分组i的话，都会导致解密后的明文分组k（k&gt;=i)的发生不可控的变化。 填充提示攻击（padding Oracle attack） 明文不为分组长度整数倍时，需要再最后一个分组中填充数据来凑满。 攻击者反复尝试发送密文和不同的填充数据。接受者无法解密后会返回错误信息。 攻击者利用错误信息可以获得一部分和明文相关的信息。 CFB模式CFB模式中，前一个密文会被送回到密码算法的输入端。 CFB模式的攻击重放攻击攻击者可利用历史的密文分组将历史的明文插入到解密的明文中。 OFB模式OFB模式将密码算法的输出反馈到密码算法的输入中。 CTR模式利用逐次累加的计数器来加密生成密钥流的流密码。 各个模式的对比","link":"/2020/06/12/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"},{"title":"密码学-消息认证码MAC","text":"消息认证码是将key和消息msg混合后输出一个用于认证的auth_code。 1234graph LR A(key) -- input --&gt; B(MAC-Algo) C(msg) -- input --&gt; B B -- output --&gt; D(mac_code) MAC为什么能做认证? 双方以某种方式交换某个秘密MAC密钥(预共享密钥)。 我们收到来自某处的message + auth_code(例如，从互联网，从区块链，或电子邮件消息)。 我们希望确保message没有被篡改，这意味着key和message都是正确的，并匹配MAC。 如果有篡改的消息，MAC将是不正确的。 实际场景下message在channel中通常是加密的，这种情形下可以用MAC来认证加密消息。 常见的MAC算法 基于hash的MAC算法 HMAC (Hash-based MAC, e.g. HMAC-SHA256) KMAC (Keccak-based MAC) 基于对称加密的MAC算法 CMAC (Cipher-based MAC) GMAC (Galois MAC) Poly1305 (Bernstein’s one-time authenticator) 其他 UMAC (based on universal hashing)- VMAC (high-performance block cipher-based MAC) SipHash (simple, fast, secure MAC) HMAC原理hmac是一种常见的mac算法，其构造的原理如图所示： 其中： IV：随机生成的向量 k: 就是mac算法需要的key ipad：0x5C的填充 opad: 0x36的填充 m: message被分割成的若干端 t：最后的输出","link":"/2020/06/12/%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81MAC/"},{"title":"c++函数对象","text":"什么是函数对象？若一个类如果重载了运算符 “()”，则该类的对象就成为函数对象。一个典型的函数对象： 12345678class Mycompare{public: int operator()(const int &amp;a, const int &amp;b) { return a &gt; b; }}; 当然函数类可以定义为模板类 123456789template &lt;typename T&gt;class Mycompare2{public: int operator()(const T &amp;a, const T &amp;b) { return a &lt; b; }}; 函数类也可以拥有自己的成员变量，譬如： 123456789class Mycompare{int maxVal;public: int operator()(const int &amp;a, const int &amp;b) { return a &gt; b; }}; 函数对象使用场景函数定义了对数据的操作，有了函数对象，我们在泛型编程中可以充分发挥想象力，让算法中的对数据的操作变成我们想要的。比如对排序算法： 12sort(nums.begin(),nums.end(),Mycompare());//降序排sort(nums.begin(),nums.end(),Mycompare2&lt;int&gt;());//升序拍 函数指针我们可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量称为“函数指针”。 12345678910template &lt;typename T&gt;T MyPower( T a, int power) { T tmp = a; for(int i=0;i&lt;power-1;i++) tmp *= a; a = tmp; return a;}int (* pf)(int,int);pf = MyPower&lt;int&gt;;cout &lt;&lt; pf(10,2)&lt;&lt;endl; 函数对象和函数指针的区别用函数对象代替函数指针有几个优点： 首先，因为对象可以在内部修改而不用改动外部接口，因此设计更灵活，更富有弹性。函数对象也具备有存储先前调用结果的数据成员。在使用普通函数时需要将先前调用的结果存储在全局或者本地静态变量中，但是全局或者本地静态变量有某些我们不愿意看到的缺陷。 其次，在函数对象中编译器能实现内联调用(编译器能内联重载的操作符代码，所以就避免了与函数调用相关的运行时问题)，从而更进一步增强了性能。这在函数指针中几乎是不可能实现的。 模板函数对象: 增加函数对象的通用性。","link":"/2020/06/12/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"},{"title":"密码学-hash函数","text":"哈希函数将文本或二进制数据转换为固定长度的散列值，并且要具有抗冲突性和不可逆性。 抗冲突 意味着输入不同，hash函数的输出不同。或者说很难找的两个输入，他们的hash值是一样的。 不可逆 计算hash值很容易，但是根据hash值推断出hash函数的输入很难，其概率是可忽略的。 123456789graph LR subgraph 抗冲突 A(&quot;hash(x)&quot;) -- easy --&gt; B(y) C(&quot;hash(x')&quot;) -- very hard --&gt; B end subgraph 不可逆 B1 -- very hard --&gt; A1 A1(&quot;hash(x)&quot;) -- easy --&gt; B1(y) end 常用的哈希算法现在密码学是不断发展的，没有绝对安全的哈希算法。过去有些常用的哈希算法已经被证明不安全的(MD5、SHA0、SHA1),有些现在仍然被认为是安全的，比如SHA-2，SHA-3和BLAKE2。但这并不意味着以后这些算法依然安全。 目前安全的哈希算法 SHA-2, SHA-256, SHA-512 SHA-3, SHA3-256, SHA3-512, Keccak-256 BLAKE2, BLAKE2s , BLAKE2b 哈希函数的用途 验证数据完整性对文件计算hash可验证文件的内容是否被篡改。 保护密码保存密码的hash值，而不保存密码的明文。这样攻击者拿到密码的hash也无法得到密码。 生成唯一id由于hash函数是抗冲突的，可用hash函数对文件/数据计算hash值，并将这个值作为文件/数据的唯一id。 pow算法hash函数是不可逆的，想要构造一个值，使得它的hash值满足特定的要求是很困难的。需要不停的尝试和计算，还需要一些运气。pow算法要求矿工不断的尝试nonce，使得hash(nonce+x)的值满足前64(该值可动态调整)个bit为0。 计算伪随机数生成器","link":"/2020/06/12/%E5%AF%86%E7%A0%81%E5%AD%A6-hash%E5%87%BD%E6%95%B0/"},{"title":"c++智能指针","text":"为什么要用智能指针？c++的内存管理是让很多人头疼的事，当我们new一个资源时，需要相应的delete语句把资源释放了。但是当程序变得十分庞大时，亦或程序员的粗心大意所致，delete语句没有写或没有执行是难以避免的。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。 shared_ptr 多个share_ptr可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 每次复制之后引用计数加一，不再指向对象（自身销毁或指向其他对象）时时引用计数减一，减至零值调用所管理资源对象的析构函数。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁。12345678910111213141516171819struct A { int n; A(){} A (int i):n(i) {} ~A() {cout&lt;&lt;n&lt;&lt;\" destruct\"&lt;&lt;endl;}};int main() { cout &lt;&lt; \"使用share_ptr托管资源\"&lt;&lt;endl; shared_ptr&lt;A&gt; sp1(new A(1));//sp1托管A(1) shared_ptr&lt;A&gt; sp2(sp1);//sp2也托管A(1) shared_ptr&lt;A&gt; sp3 = sp2;//sp3也托管A(1) // shared_ptr&lt;A&gt; sp4(new A[10]);//错误！智能指针不能管理数组类型 cout &lt;&lt; \"访问托管资源\"&lt;&lt;endl; cout &lt;&lt; \"sp1 \"&lt;&lt;sp1-&gt;n&lt;&lt;\" sp2 \"&lt;&lt;sp2-&gt;n&lt;&lt;\" sp3 \"&lt;&lt;sp3-&gt;n&lt;&lt;endl; A *ptr = sp1.get();//获取托管的资源 cout &lt;&lt; \"A' ptr \"&lt;&lt;ptr-&gt;n&lt;&lt;endl; sp1.reset();//放弃托管资源 if(!sp1) cout &lt;&lt; \"sp1放弃托管\" &lt;&lt;endl;} 使用share_ptr时，需要注意对资源进行托管的方式。12345ptr = new A(2);sp1.reset(ptr);//sp1托管A(2)cout &lt;&lt; \"sp1 \"&lt;&lt;sp1-&gt;n&lt;&lt;endl;shared_ptr&lt;A&gt; sp4(ptr);//错误！sp4托管A(2)，并不会增加A(2)的计数，导致资源会被多次删除cout &lt;&lt; \"sp4 \"&lt;&lt;sp4-&gt;n&lt;&lt;endl; 如果用两个智能指针以资源指针的形式托管同一个资源，这样并不会增加计数，而且会导致资源的多次释放，导致程序错误。 weak_ptr weak_ptr 允许共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。 在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用的问题。12345678910struct B;struct A { std::shared_ptr&lt;B&gt; b; ~A() { std::cout &lt;&lt; \"~A()\\n\"; }};struct B { std::shared_ptr&lt;A&gt; a; ~B() { std::cout &lt;&lt; \"~B()\\n\"; } }; 可以看到A和B是环状引用的，这种情况下shared_ptr是无法释放资源的。123456auto a = std::make_shared&lt;A&gt;();auto b = std::make_shared&lt;B&gt;();a-&gt;b = b;b-&gt;a = a;std::cout&lt;&lt;a.use_count()&lt;&lt;std::endl;//2std::cout&lt;&lt;b.use_count()&lt;&lt;std::endl;//2 如上所示，每个资源的引用计数均为2。A被a和b-&gt;a引用，B被b和a-&gt;b引用，这样程序结束时不会调用A和B的析构函数的。使用weak_ptr可打破环状引用。将struct B改为：1234567891011struct B {// std::shared_ptr&lt;A&gt; a; std::weak_ptr&lt;A&gt; a; ~B() { std::cout &lt;&lt; \"~B()\\n\"; } };auto a = std::make_shared&lt;A&gt;();auto b = std::make_shared&lt;B&gt;();a-&gt;b = b;b-&gt;a = a;std::cout&lt;&lt;a.use_count()&lt;&lt;std::endl;//1std::cout&lt;&lt;b.use_count()&lt;&lt;std::endl;//2 weak_ptr不会增加引用计数，所以A被b引用，B被a-&gt;b和b引用。当A被释放后，B的引用变成1，自然也可以被释放了。 unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。 采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。 一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 可以管理数组（析构调用 delete[] ）1234567891011121314151617unique_ptr&lt;A&gt; p1(new A); // returns the memory address of p1 cout &lt;&lt; p1.get() &lt;&lt; endl; //0x7fffefb06e70// transfers ownership to p2 unique_ptr&lt;A&gt; p2 = move(p1); cout &lt;&lt; p1.get() &lt;&lt; endl; //0cout &lt;&lt; p2.get() &lt;&lt; endl; //0x7fffefb06e70// transfers ownership to p3 unique_ptr&lt;A&gt; p3 = move(p2); cout &lt;&lt; p1.get() &lt;&lt; endl; //0cout &lt;&lt; p2.get() &lt;&lt; endl; //0cout &lt;&lt; p3.get() &lt;&lt; endl;//0x7fffefb06e70unique_ptr&lt;A[]&gt; p4(new A[5]);cout &lt;&lt; p4.get() &lt;&lt; endl; //0x7fffefb072a8// unique_ptr&lt;A&gt; p5 = p4; auto_ptr被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；","link":"/2020/06/12/c-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"raft","slug":"raft","link":"/tags/raft/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"categories":[]}