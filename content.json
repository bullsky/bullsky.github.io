{"pages":[],"posts":[{"title":"RAFT实现之leader election","text":"leader选举基本流程 所有节点以follower启动 follower的选举时钟超时，转为candidate candidate向其他节点发送投票请求，如果收到过半节点的投票，则成为leader leader周期性向其他节点发送心跳包以维持权威 实现关键点： 1.状态转移：raft节点的状态转移要严格依据下图，不管节点处于什么状态，只要发现更大的Term，都转为follower。对于candidate，如果收到新leader的心跳包，则转为follower。 2.选举时钟如果节点状态不是leader，选举时钟需要周期性的检查是否过期: 123456789101112131415func (rf *Raft) PeriodicRequestVote() { for { rf.mu.Lock() //检查状态是不是leader,如果不是，检查election time 有没有超时 ，超时，则状态转为candidate if rf.state != leader &amp;&amp; rf.electionTimer+rf.timeperiod &lt; time.Now().UnixNano() { //转到c尝试成为leader rf.mu.Unlock() rf.AttemptBeLeader() } else { rf.mu.Unlock() } // rf.mu.Unlock() time.Sleep(electionInterval*time.Millisecond) } } 重置选举时钟的3种情形： 从leader处收到appendentriesRPC调用（如果leader的term过期则不用重置） 开始新的一轮选举 给其他节点投票（收到requestVoteRPC调用） 3.RequestVoteRPC接受者（follow，candidate，leader）实现除了图中的1、2，还需要注意： 检查是否收到更大的term，如果收到，更新term并转为follower状态，如果已经是follower，则更新term和重置votedFor 1234567//如果候选人的term小于自己的termif term&lt;rf.currentTerm { reply.VoteGranted = false return} else if term &gt; rf.currentTerm { //收到更高的term，更新term,转为follwer rf.convertToFollwer(term)} 如果决定给候选人投票，需要将自己的当前term返回，这里强调当前term（currentTerm）是因为follower可能因为在正式返回投票结果前更新了自己的currentTerm（比如收到更大的term） 123456if (rf.votedFor==-1 || rf.votedFor==candidateid) &amp;&amp; (lastLogTerm &gt; lastTerm || lastLogTerm==lastTerm &amp;&amp; lastLogIndex&gt;=lastIndex) { reply.Term = rf.currentTerm reply.VoteGranted = true //将投票人修改(add my) rf.votedFor=candidateid 发送者收到RPC调用结果后，需要注意： 是否是过期的rpc回复（即term小于自己的term），丢弃不处理 1234 //如果收到过期的term，丢弃 if rf.state!=candidate || reply.Term &lt; rf.currentTerm { return false } 返回的term是否大于自己的term，是则转为follower 1234 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } candidate统计选票时得把自己算上 守护进程定时检查节点是否成为leader，成为leader后定时周期发起AppendEntriesRPC。 123456789101112func (rf *Raft) PeriodicAppendEnties() { for { rf.mu.Lock() if rf.state == leader { rf.mu.Unlock() rf.AttemptReplication() } else { rf.mu.Unlock() } time.Sleep(heartbeatInterval*time.Millisecond) } } 测试全部通过","link":"/2020/05/24/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Bleader-election/"},{"title":"c++常量const","text":"常量 常量值不可更改 123const int val = 20;val = 22;//errorval = 20;//error,不允许有赋值操作 常量指针 const type * 不可通过常量指针修改其指向的内容 1234int val2 = 30;const int * ptr = &amp;val2;*ptr = 40;//errorval2 = 40;//ok,val2不是常量可以更改 type * const不可更改指针值 123int * const ptr2 = &amp;val2;*ptr2 = 50;//okptr2 = ptr;//error 常量引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 常成员函数 类成员函数后面加const关键字 常成员函数不能修改对象的成员变量的值 除了静态成员变量，因为静态成员变量不属于某个对象 常成员函数不能调用类的非常成员函数 非常成员函数可能会修改成员变量的值 除了静态成员函数，因为静态成员函数不属于某个对象123456789101112131415161718class test{ int n;public: test() { n = 1; }; // int set(int i) const {n=i;}//error,常成员函数不能更改成员变量 int set(int i) {} int get() const { return n; } int get() { return n; } //重载};int main() { const test t1; test t2; //t1.set(2);//error,常量对象不能调用非常量成员函数 t2.set(2); cout &lt;&lt; t1.get() &lt;&lt; \" \" &lt;&lt; t2.get() &lt;&lt; endl;}","link":"/2020/05/31/c-%E5%B8%B8%E9%87%8Fconst/"},{"title":"c++内联函数","text":"函数调用是有开销的，对于函数体较小却又多次执行的函数，总的开销就会显得比较大 编译期处理内敛函数的调用语句时，是将函数体的代码插入到调用语句出，这样就不会避免了函数调用。 1234567891011inline int max(int a, int b){ if (a &gt; b) return a; else return b;}int main(){ cout &lt;&lt; max(1, 3) &lt;&lt; endl;} 内联成员函数 成员函数前有inline关键字 成员函数定义在类内部 1234567class testInline{public: void func1(){}; //inline void func2();};inline void testInline::func2() {} //inline","link":"/2020/05/31/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"c++引用和指针","text":"引用 变量的引用等价于该变量，引用就是变量的别名 1234567int n = 4;int &amp;ref = n;//ref引用ncout &lt;&lt;ref&lt;&lt;endl;//4n = 5;//改变ncout&lt;&lt;ref&lt;&lt;endl;//5int &amp;ref2 = ref;cout&lt;&lt;ref2&lt;&lt;endl;//5 引用必须初始化为某个变量 12int &amp;ref2 = 2;//常量，errorint &amp;ref3 = n*5;//表达式，error 引用不能更换引用其他变量 1234int &amp;ref = n;//ref引用nint m = 6;ref = m;//ok,赋值操作ref = &amp;m;//error 常引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 指针","link":"/2020/05/31/c-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/"},{"title":"c++构造函数","text":"构造函数是一种特殊的成员函数，具有如下特点： 名字和类名相同，可以有参数，但是不能有返回值。 负责对对象进行初始化操作，生成对象时调用1次，此后不会被调用。 未定义构造函数，编译器会自动生成一个无参的构造函数，该函数没有任何操作。 构造函数可以被重载。 1234567891011121314151617181920212223242526class Node{private: /* data */ double key,value;public: Node(){}; Node(int k,int v=0); Node(double k,double v); double getKey() {return key;} ~Node(){};};Node::Node(int k,int v) { key = double(k);value = double(v);}Node::Node(double k,double v) { key=k;value=v;}int main() { Node n1; Node n2(1); Node n3(2,3); Node n4(1,2,3);//error，参数个数不匹配 Node *ptr4 = new Node(1.2,2.2); Node *ptr6 = new Node(1.2,2);//error,参数类型不匹配} 复制构造函数 复制构造函数只能有一个参数：同类对象的引用(type &amp; or const type &amp;) 未定义复制构造函数，编译器会自动生成一个复制构造函数。1234567891011121314151617181920class Node{private: /* data */ double key,value;public: Node(){}; Node(const Node&amp; node); ~Node(){};};Node::Node(const Node&amp; node) { key = node.key; value = node.value; cout &lt;&lt; \"copy constructor called\"&lt;&lt;endl;}int main() { Node n1; Node n4(n1); Node * ptr6 = new Node(n1);} 复制构造函数的使用 初始化对象时1Node n2(n1); 函数参数为对象时12345void func(Node node){};int main() { Node n4(3); func(n4);//调用复制构造函数} 函数返回值为对象时,如果没有调用，则是编译期做了优化12345678Node func1() { Node n(3); return n;}int main() { cout &lt;&lt; func1().getKey()&lt;&lt;endl; //如果没有调用复制构造函数，是编译器做了优化，不再产生临时对象} 类型转换构造函数 实现类型的自动转换 只有一个参数 转换构造函数会建立一个临时对象 12345678910111213141516171819class Node{private: /* data */ double key,value;public: Node(){}; Node(int k);//类型转换构造函数 double getKey() {return key;} ~Node(){};};Node::Node(int k) { key = double(k);value = 0; cout &lt;&lt; \"typeTrans constructor called\"&lt;&lt;endl;}int main(){ Node n5; n5 = 6;//类型转换}","link":"/2020/05/31/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"RAFT实现之log Replication","text":"实现要点1.AppendEntriesRPC接收者（follower，candidate）除了实现图中的1~5，还需要注意以下几点： 收到更大的term，或者candidate收到leader的心跳包，转为follower 1234567 //收到更高的term，更新term,转为follwer if leaderTerm &gt; rf.currentTerm { rf.convertToFollwer(leaderTerm)//候选人收到leader的心跳包，转为follwer } else if leaderTerm == rf.currentTerm &amp;&amp; rf.state == candidate { rf.convertToFollwer(leaderTerm) } 如果follower日志和leader的冲突，需要将冲突信息（conflictTerm、conflictIndex）返回给leader，这里是论文中的方法优化版，可以让leader迅速定位冲突的日志位置。 1234567891011121314151617181920212223 if prevLogIndex &gt;= len(rf.log) {//如果prevLogIndex处的日志不存在 reply.Success = false reply.ConflictIndex = len(rf.log) reply.ConflictTerm = -1 return //如果prevLogIndex的日志存在，但是term不一致 } else if rf.log[prevLogIndex].Term != prevLogTerm { reply.Success = false reply.ConflictTerm = rf.log[prevLogIndex].Term flag := false //返回冲突term的最开始的index for i:=prevLogIndex-1;i&gt;=0;i-- { if rf.log[i].Term != reply.ConflictTerm { reply.ConflictIndex = i+1 flag = true break; } } if !flag { reply.ConflictIndex = 0 } return } 2.RPC回复处理发送者（leader）收到rpc调用的回复后，需要注意以下几点： 收到更大的term或过期的term，做相应的处理 12345678 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } //如果收到过期的term,丢弃 if rf.state!=leader || reply.Term &lt; rf.currentTerm { return false } 正确的更新nextIndex、matchIndex，根据rpc调用时的entries的长度来更新，而不是自己的log长度 12rf.nextIndex[serverid] = args.PrevLogIndex+len(args.Entries)+1rf.matchIndex[serverid] = args.PrevLogIndex+len(args.Entries) 要迅速定位和follower的冲突日志的index，以一个term为单位来检查是否有冲突，而不是一个个entry来找 12345678910111213141516 //加速检查 firstConflict := reply.ConflictIndex if reply.ConflictTerm != -1 { flag := false for i,entry := range rf.log { if entry.Term == reply.ConflictTerm { if !flag { flag = true } firstConflict = i } else if flag { break } } } rf.nextIndex[serverid] = firstConflict 3.提交状态机一个守护进程周期性的检查能否提交状态机 123456789101112131415161718192021func (rf *Raft) PeriodicApplyMsg() { for { //检查commitIndex &gt; lastApplied //大于则增加lastApplied,并提交到状态机 rf.mu.Lock() var applyLogs []entry commitIndex := rf.commitIndex lastApply := rf.lastApplied if commitIndex &gt; lastApply { applyLogs = rf.log[lastApply+1:commitIndex+1] rf.lastApplied = commitIndex } rf.mu.Unlock() if len(applyLogs) &gt; 0 { for i,entry := range applyLogs { rf.applyCh &lt;- ApplyMsg{true,entry.Command,lastApply+1+i} } } time.Sleep(10*time.Millisecond) }} 这里需要注意两点： 1. 提交的时候不要给applyCh加锁，因为上锁会阻塞channel（？？？理由待验证） 2. 为了效率，要一次性把能提交的一块提交。 测试通过","link":"/2020/05/31/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Blog-Replication/"},{"title":"c++ static","text":"静态成员变量 成员变量前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局变量 使用静态变量必须在类外部初始化 123456789101112class testStatic{private: int m;public: static int n;};//外部初始化int testStatic::n = 0;int main() { cout&lt;&lt;sizeof(testStatic)&lt;&lt;endl;//4} 如何访问? 类名::成员变量名1testStatic::n 对象名.成员变量名12testStatic t1;t1.n; 指针-&gt;成员变量名12testStatic *ptr = t2;t2-&gt;n; 引用-&gt;成员变量名12testStatic &amp;ptr = t2;t2-&gt;n; 静态成员函数 成员函数前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局函数 不能访问非静态成员变量 不能调用非静态成员函数1234567891011class testStatic{private: int m;public: static int n; static void prinfs(){ cout&lt;&lt;n&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl;//error,不能访问非static成员变量 }}; 静态成员函数访问方法和静态成员变量一致。","link":"/2020/06/01/c-static/"},{"title":"c++ this","text":"this指针指向成员函数所作用的对象 静态成员函数不能使用this指针 因为静态成员函数不属于某个对象 123456789101112131415class testThis{ int n;public: void hello() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } void printn() { cout &lt;&lt; this-&gt;n &lt;&lt; endl; }};int main(){ testThis *ptr = NULL; ptr-&gt;hello();//ok,函数体为用到this指针 ptr-&gt;printn();//error,this指针为空}","link":"/2020/06/01/c-this/"},{"title":"c++析构函数","text":"析构函数在对象消亡时会被自动调用，用于释放内存空间等操作 析构函数与类名相同 没有参数和返回值 不能重载，只能有一个析构函数 没有定义析构函数，编译期会自动生成析构函数，该析构函数不做任何事 123456789101112131415161718class String{private: char *p;public: String() { p = new char[10]; }; ~String();};String::~String(){ delete[] p; cout &lt;&lt; \"destructor called\"&lt;&lt;endl;} 一个对象生命周期结束时会调用析构函数； 如果是对象数组，则数组中的每个对象的析构函数都会被调用; 如果是指针类型，需要通过delete来调用析构函数123456int main() { String str; String strlist[3]; String * ptr = new String; delete ptr;} 输出12345destructor called //strdestructor called //strlist[0]destructor called //strlist[1]destructor called //strlist[2]destructor called //*ptr 同一作用域内，先构造的对象后析构 123456789101112131415161718192021222324252627282930313233343536class String{private: int id;public: String(){}; String(int i); String(char ch); ~String();};String::~String(){ cout &lt;&lt; id &lt;&lt; \" destructor called\" &lt;&lt; endl;}String::String(int i){ id = i; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;};String::String(char ch){ id = ch - '0'; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;}int main(){ String str1(1); str1 = '6'; if (1) { String str2(2); } String str3(3);} 输出123456781 constructor called6 constructor called 6 destructor called //赋值是生成的临时变量2 constructor called2 destructor called3 constructor called3 destructor called6 destructor called","link":"/2020/06/01/c-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"raft","slug":"raft","link":"/tags/raft/"}],"categories":[]}