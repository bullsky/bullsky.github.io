{"pages":[],"posts":[{"title":"RAFT实现之leader election","text":"leader选举基本流程 所有节点以follower启动 follower的选举时钟超时，转为candidate candidate向其他节点发送投票请求，如果收到过半节点的投票，则成为leader leader周期性向其他节点发送心跳包以维持权威 实现关键点： 1.状态转移：raft节点的状态转移要严格依据下图，不管节点处于什么状态，只要发现更大的Term，都转为follower。对于candidate，如果收到新leader的心跳包，则转为follower。 2.选举时钟如果节点状态不是leader，选举时钟需要周期性的检查是否过期: 123456789101112131415func (rf *Raft) PeriodicRequestVote() { for { rf.mu.Lock() //检查状态是不是leader,如果不是，检查election time 有没有超时 ，超时，则状态转为candidate if rf.state != leader &amp;&amp; rf.electionTimer+rf.timeperiod &lt; time.Now().UnixNano() { //转到c尝试成为leader rf.mu.Unlock() rf.AttemptBeLeader() } else { rf.mu.Unlock() } // rf.mu.Unlock() time.Sleep(electionInterval*time.Millisecond) } } 重置选举时钟的3种情形： 从leader处收到appendentriesRPC调用（如果leader的term过期则不用重置） 开始新的一轮选举 给其他节点投票（收到requestVoteRPC调用） 3.RequestVoteRPC接受者（follow，candidate，leader）实现除了图中的1、2，还需要注意： 检查是否收到更大的term，如果收到，更新term并转为follower状态，如果已经是follower，则更新term和重置votedFor 1234567//如果候选人的term小于自己的termif term&lt;rf.currentTerm { reply.VoteGranted = false return} else if term &gt; rf.currentTerm { //收到更高的term，更新term,转为follwer rf.convertToFollwer(term)} 如果决定给候选人投票，需要将自己的当前term返回，这里强调当前term（currentTerm）是因为follower可能因为在正式返回投票结果前更新了自己的currentTerm（比如收到更大的term） 123456if (rf.votedFor==-1 || rf.votedFor==candidateid) &amp;&amp; (lastLogTerm &gt; lastTerm || lastLogTerm==lastTerm &amp;&amp; lastLogIndex&gt;=lastIndex) { reply.Term = rf.currentTerm reply.VoteGranted = true //将投票人修改(add my) rf.votedFor=candidateid 发送者收到RPC调用结果后，需要注意： 是否是过期的rpc回复（即term小于自己的term），丢弃不处理 1234 //如果收到过期的term，丢弃 if rf.state!=candidate || reply.Term &lt; rf.currentTerm { return false } 返回的term是否大于自己的term，是则转为follower 1234 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } candidate统计选票时得把自己算上 守护进程定时检查节点是否成为leader，成为leader后定时周期发起AppendEntriesRPC。 123456789101112func (rf *Raft) PeriodicAppendEnties() { for { rf.mu.Lock() if rf.state == leader { rf.mu.Unlock() rf.AttemptReplication() } else { rf.mu.Unlock() } time.Sleep(heartbeatInterval*time.Millisecond) } } 测试全部通过","link":"/2020/05/24/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Bleader-election/"},{"title":"c++常量const","text":"常量 常量值不可更改 123const int val = 20;val = 22;//errorval = 20;//error,不允许有赋值操作 常量指针 const type * 不可通过常量指针修改其指向的内容 1234int val2 = 30;const int * ptr = &amp;val2;*ptr = 40;//errorval2 = 40;//ok,val2不是常量可以更改 type * const不可更改指针值 123int * const ptr2 = &amp;val2;*ptr2 = 50;//okptr2 = ptr;//error 常量引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 常成员函数 类成员函数后面加const关键字 常成员函数不能修改对象的成员变量的值 除了静态成员变量，因为静态成员变量不属于某个对象 常成员函数不能调用类的非常成员函数 非常成员函数可能会修改成员变量的值 除了静态成员函数，因为静态成员函数不属于某个对象123456789101112131415161718class test{ int n;public: test() { n = 1; }; // int set(int i) const {n=i;}//error,常成员函数不能更改成员变量 int set(int i) {} int get() const { return n; } int get() { return n; } //重载};int main() { const test t1; test t2; //t1.set(2);//error,常量对象不能调用非常量成员函数 t2.set(2); cout &lt;&lt; t1.get() &lt;&lt; \" \" &lt;&lt; t2.get() &lt;&lt; endl;}","link":"/2020/05/31/c-%E5%B8%B8%E9%87%8Fconst/"},{"title":"c++内联函数","text":"函数调用是有开销的，对于函数体较小却又多次执行的函数，总的开销就会显得比较大 编译期处理内敛函数的调用语句时，是将函数体的代码插入到调用语句出，这样就不会避免了函数调用。 1234567891011inline int max(int a, int b){ if (a &gt; b) return a; else return b;}int main(){ cout &lt;&lt; max(1, 3) &lt;&lt; endl;} 内联成员函数 成员函数前有inline关键字 成员函数定义在类内部 1234567class testInline{public: void func1(){}; //inline void func2();};inline void testInline::func2() {} //inline","link":"/2020/05/31/c-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"title":"c++引用和指针","text":"引用 变量的引用等价于该变量，引用就是变量的别名 1234567int n = 4;int &amp;ref = n;//ref引用ncout &lt;&lt;ref&lt;&lt;endl;//4n = 5;//改变ncout&lt;&lt;ref&lt;&lt;endl;//5int &amp;ref2 = ref;cout&lt;&lt;ref2&lt;&lt;endl;//5 引用必须初始化为某个变量 12int &amp;ref2 = 2;//常量，errorint &amp;ref3 = n*5;//表达式，error 引用不能更换引用其他变量 1234int &amp;ref = n;//ref引用nint m = 6;ref = m;//ok,赋值操作ref = &amp;m;//error 常引用 不能通过常引用去修改其引用的内容 1234const int &amp;c_ref = n;int &amp;ref3 = n;c_ref = 9;//error,常引用ref3 = 9;//ok,ref3不是常引用 指针","link":"/2020/05/31/c-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/"},{"title":"c++构造函数","text":"构造函数是一种特殊的成员函数，具有如下特点： 名字和类名相同，可以有参数，但是不能有返回值。 负责对对象进行初始化操作，生成对象时调用1次，此后不会被调用。 未定义构造函数，编译器会自动生成一个无参的构造函数，该函数没有任何操作。 构造函数可以被重载。 1234567891011121314151617181920212223242526class Node{private: /* data */ double key,value;public: Node(){}; Node(int k,int v=0); Node(double k,double v); double getKey() {return key;} ~Node(){};};Node::Node(int k,int v) { key = double(k);value = double(v);}Node::Node(double k,double v) { key=k;value=v;}int main() { Node n1; Node n2(1); Node n3(2,3); Node n4(1,2,3);//error，参数个数不匹配 Node *ptr4 = new Node(1.2,2.2); Node *ptr6 = new Node(1.2,2);//error,参数类型不匹配} 复制构造函数 复制构造函数只能有一个参数：同类对象的引用(type &amp; or const type &amp;) 未定义复制构造函数，编译器会自动生成一个复制构造函数。1234567891011121314151617181920class Node{private: /* data */ double key,value;public: Node(){}; Node(const Node&amp; node); ~Node(){};};Node::Node(const Node&amp; node) { key = node.key; value = node.value; cout &lt;&lt; \"copy constructor called\"&lt;&lt;endl;}int main() { Node n1; Node n4(n1); Node * ptr6 = new Node(n1);} 复制构造函数的使用 初始化对象时1Node n2(n1); 函数参数为对象时12345void func(Node node){};int main() { Node n4(3); func(n4);//调用复制构造函数} 函数返回值为对象时,如果没有调用，则是编译期做了优化12345678Node func1() { Node n(3); return n;}int main() { cout &lt;&lt; func1().getKey()&lt;&lt;endl; //如果没有调用复制构造函数，是编译器做了优化，不再产生临时对象} 类型转换构造函数 实现类型的自动转换 只有一个参数 转换构造函数会建立一个临时对象 12345678910111213141516171819class Node{private: /* data */ double key,value;public: Node(){}; Node(int k);//类型转换构造函数 double getKey() {return key;} ~Node(){};};Node::Node(int k) { key = double(k);value = 0; cout &lt;&lt; \"typeTrans constructor called\"&lt;&lt;endl;}int main(){ Node n5; n5 = 6;//类型转换}","link":"/2020/05/31/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"RAFT实现之log Replication","text":"实现要点1.AppendEntriesRPC接收者（follower，candidate）除了实现图中的1~5，还需要注意以下几点： 收到更大的term，或者candidate收到leader的心跳包，转为follower 1234567 //收到更高的term，更新term,转为follwer if leaderTerm &gt; rf.currentTerm { rf.convertToFollwer(leaderTerm)//候选人收到leader的心跳包，转为follwer } else if leaderTerm == rf.currentTerm &amp;&amp; rf.state == candidate { rf.convertToFollwer(leaderTerm) } 如果follower日志和leader的冲突，需要将冲突信息（conflictTerm、conflictIndex）返回给leader，这里是论文中的方法优化版，可以让leader迅速定位冲突的日志位置。 1234567891011121314151617181920212223 if prevLogIndex &gt;= len(rf.log) {//如果prevLogIndex处的日志不存在 reply.Success = false reply.ConflictIndex = len(rf.log) reply.ConflictTerm = -1 return //如果prevLogIndex的日志存在，但是term不一致 } else if rf.log[prevLogIndex].Term != prevLogTerm { reply.Success = false reply.ConflictTerm = rf.log[prevLogIndex].Term flag := false //返回冲突term的最开始的index for i:=prevLogIndex-1;i&gt;=0;i-- { if rf.log[i].Term != reply.ConflictTerm { reply.ConflictIndex = i+1 flag = true break; } } if !flag { reply.ConflictIndex = 0 } return } 2.RPC回复处理发送者（leader）收到rpc调用的回复后，需要注意以下几点： 收到更大的term或过期的term，做相应的处理 12345678 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } //如果收到过期的term,丢弃 if rf.state!=leader || reply.Term &lt; rf.currentTerm { return false } 正确的更新nextIndex、matchIndex，根据rpc调用时的entries的长度来更新，而不是自己的log长度 12rf.nextIndex[serverid] = args.PrevLogIndex+len(args.Entries)+1rf.matchIndex[serverid] = args.PrevLogIndex+len(args.Entries) 要迅速定位和follower的冲突日志的index，以一个term为单位来检查是否有冲突，而不是一个个entry来找 12345678910111213141516 //加速检查 firstConflict := reply.ConflictIndex if reply.ConflictTerm != -1 { flag := false for i,entry := range rf.log { if entry.Term == reply.ConflictTerm { if !flag { flag = true } firstConflict = i } else if flag { break } } } rf.nextIndex[serverid] = firstConflict 3.提交状态机一个守护进程周期性的检查能否提交状态机 123456789101112131415161718192021func (rf *Raft) PeriodicApplyMsg() { for { //检查commitIndex &gt; lastApplied //大于则增加lastApplied,并提交到状态机 rf.mu.Lock() var applyLogs []entry commitIndex := rf.commitIndex lastApply := rf.lastApplied if commitIndex &gt; lastApply { applyLogs = rf.log[lastApply+1:commitIndex+1] rf.lastApplied = commitIndex } rf.mu.Unlock() if len(applyLogs) &gt; 0 { for i,entry := range applyLogs { rf.applyCh &lt;- ApplyMsg{true,entry.Command,lastApply+1+i} } } time.Sleep(10*time.Millisecond) }} 这里需要注意两点： 1. 提交的时候不要给applyCh加锁，因为上锁会阻塞channel（？？？理由待验证） 2. 为了效率，要一次性把能提交的一块提交。 测试通过","link":"/2020/05/31/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Blog-Replication/"},{"title":"c++ static","text":"静态成员变量 成员变量前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局变量 使用静态变量必须在类外部初始化 123456789101112class testStatic{private: int m;public: static int n;};//外部初始化int testStatic::n = 0;int main() { cout&lt;&lt;sizeof(testStatic)&lt;&lt;endl;//4} 如何访问? 类名::成员变量名1testStatic::n 对象名.成员变量名12testStatic t1;t1.n; 指针-&gt;成员变量名12testStatic *ptr = t2;t2-&gt;n; 引用-&gt;成员变量名12testStatic &amp;ptr = t2;t2-&gt;n; 静态成员函数 成员函数前有static关键字 不具体作用于某一个对象 只有一份，所有对象共享一份 不通过对象也能访问，是全局函数 不能访问非静态成员变量 不能调用非静态成员函数1234567891011class testStatic{private: int m;public: static int n; static void prinfs(){ cout&lt;&lt;n&lt;&lt;endl; //cout&lt;&lt;m&lt;&lt;endl;//error,不能访问非static成员变量 }}; 静态成员函数访问方法和静态成员变量一致。","link":"/2020/06/01/c-static/"},{"title":"c++ this","text":"this指针指向成员函数所作用的对象 静态成员函数不能使用this指针 因为静态成员函数不属于某个对象 123456789101112131415class testThis{ int n;public: void hello() { cout &lt;&lt; \"hello\" &lt;&lt; endl; } void printn() { cout &lt;&lt; this-&gt;n &lt;&lt; endl; }};int main(){ testThis *ptr = NULL; ptr-&gt;hello();//ok,函数体为用到this指针 ptr-&gt;printn();//error,this指针为空}","link":"/2020/06/01/c-this/"},{"title":"c++析构函数","text":"析构函数在对象消亡时会被自动调用，用于释放内存空间等操作 析构函数与类名相同 没有参数和返回值 不能重载，只能有一个析构函数 没有定义析构函数，编译期会自动生成析构函数，该析构函数不做任何事 123456789101112131415161718class String{private: char *p;public: String() { p = new char[10]; }; ~String();};String::~String(){ delete[] p; cout &lt;&lt; \"destructor called\"&lt;&lt;endl;} 一个对象生命周期结束时会调用析构函数； 如果是对象数组，则数组中的每个对象的析构函数都会被调用; 如果是指针类型，需要通过delete来调用析构函数123456int main() { String str; String strlist[3]; String * ptr = new String; delete ptr;} 输出12345destructor called //strdestructor called //strlist[0]destructor called //strlist[1]destructor called //strlist[2]destructor called //*ptr 同一作用域内，先构造的对象后析构 123456789101112131415161718192021222324252627282930313233343536class String{private: int id;public: String(){}; String(int i); String(char ch); ~String();};String::~String(){ cout &lt;&lt; id &lt;&lt; \" destructor called\" &lt;&lt; endl;}String::String(int i){ id = i; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;};String::String(char ch){ id = ch - '0'; cout &lt;&lt; id &lt;&lt; \" constructor called\" &lt;&lt; endl;}int main(){ String str1(1); str1 = '6'; if (1) { String str2(2); } String str3(3);} 输出123456781 constructor called6 constructor called 6 destructor called //赋值是生成的临时变量2 constructor called2 destructor called3 constructor called3 destructor called6 destructor called","link":"/2020/06/01/c-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"},{"title":"c++重载","text":"运算符重载 c++中预定义的运算符最初只能对基本的数据类型进行操作。 对已有的运算符赋予多重的含义。 使同一运算符作用于不同类型的数据时，有不同类型的行为。 目的扩展C++中提供的运算符的适用范围, 以用于类所表示的抽象数据类型。 运算符重载需要注意： 运算符重载不改变运算符的优先级 以下运算符不能被重载： “.”, “.*”, “::”, “?:”, sizeof 重载运算符(), [ ], -&gt;或者赋值运算符=时, 重载函数必须声明为类的成员函数 原理在程序编译时: 把含运算符的表达式 –&gt; 对运算符函数的调用 把运算符的操作数 –&gt; 运算符函数的参数 运算符被多次重载时, 根据实参的类型决定调用哪个运算符函数 重载为普通函数 参数个数为运算符目数 12345678910111213141516171819class complex{public: double r, i; complex(double a, double b) { a = r; b = i; }};complex operator+ (const complex&amp; a,const complex&amp; b) { return complex(a.r+b.r,a.i+b.i);}int main(){ complex a(1,1),b(2,1),c; c=a+b;//==&gt;c=operator+(a,b)} 重载为成员函数 参数个数为运算符目数减一 1234567891011121314151617181920class complex{public: double r, i; complex(){}; complex(double a, double b) { a = r; b = i; } //重载为成员函数 complex operator-(const complex&amp; b) { return complex(r-b.r,i-b.i); }};int main(){ complex a(1,1),b(2,1),c; c = a-b;//==&gt;c = a.operator-(b)} 赋值运算符重载正常情况下，赋值运算符可作用于自定义的数据类型上，比如定义了一个字符串类： 12345678910111213class myString{ char *str; int size;public: myString() : str(NULL),size(0) {} myString(const char *s); myString(const myString &amp;s); void printaddr() { cout &lt;&lt; (void *)str &lt;&lt; endl; } void printstring() { cout &lt;&lt; str &lt;&lt; endl; } int length() {return size;} ~myString() { if(str) delete [] str; }}; 如果使用=来进行赋值操作会发生什么呢? 12345678910int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7ffff01bce70 str2.printaddr();//0x7ffff01bce70} 所以原始的=赋值只会简单把成员变量的值变得相同，这种赋值就是浅拷贝，对于上面这个例子，仅仅是将两个指针变得指向同一份数据。这种浅拷贝的方式会有如下问题： 指针原来指向的数据没有被释放，变成垃圾内存。 如果一个指针提前释放内存中的数据，那么另一个指针就会变成野指针。 指针指向内存地址会被释放两次，可能会出现内存错误。 为了避免上述问题，我们需要另一种赋值方式-深拷贝。深拷贝是将指针指向的值拷贝过去，而不是指针本身。为了在自己定义的类中实现这个目标，需要我们定义赋值运算符重载函数 1234567891011121314151617181920212223242526272829myString &amp;myString::operator=(const myString &amp;s){ if (str == s.str) return *this; if (s.str) { if (size&lt;s.size) if(str) delete[] str; str = new char[s.size + 1]; strcpy(str, s.str); size = strlen(s.str); } else { str = NULL; size = 0; } return *this;}int main(){ myString str1(\"abc\"),str2(\"cde\"); str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90 str2 = str1;//浅拷贝 str2.printstring();//abc str1.printaddr();//0x7fffd11c0e70 str2.printaddr();//0x7fffd11c0e90} 这里将返回值定义为myString&amp;是为了能实现连续赋值，考虑以下情形： 1234myString str1(\"abc\"),str2(\"cde\"),str3(\"efg\");(str1 = str2) = str3;//(str1.opreator=(str2)).opreator=(str3)str1.printstring();//efg 第一次赋值为str1=str2,其返回值我们暂记作xxx;第二次赋值为xxx=str3;这段代码的目的是将str3的值赋给str1，如果返回值不为引用myString&amp;，那么xxx就是一个临时产生对象，不会对str1有任何影象。 []运算符重载 []运算重载需要注意返回值的类型，应当返回引用类型，这样才可以去修改数组指定下标的值。 12345678910char&amp; myString::operator[](int i) { return str[i];}int main(){ myString str1(\"abc\"); cout&lt;&lt;str1[1]&lt;&lt;endl;//a str1[0]='9'; str1.printstring();//abc} &lt;&lt;和&gt;&gt;运算符重载运算符&lt;&lt;和运算符&gt;&gt;原始含义是二进制算数左移和二进制算术右移，在ostream类和istream类中将他们重载为输出流和输入流。 12345678910ostream &amp; ostream::operator&lt;&lt;(int n){ …… //输出n的代码 return * this;}istream &amp; istream::operator&gt;&gt;(int&amp; n){ …… //输入s的代码 return * this;} 可以看到返回值均为ostream和istream类的引用，这里为了能实现输出/输入拼接。 1cout&lt;&lt;\"hello\"&lt;&lt;\"world\"; 那么如果想用ostream或istream对我们自定义的myString类执行输入输出是否可行呢？ 12myString str(\"hello\");cout &lt;&lt;str&lt;&lt;endl;//error 显然不行，因为ostream类中并没有将&lt;&lt;重载为适合myString类的输出函数，所以需要我们自己重载&lt;&lt;运算符，显然我们无法在ostream的成员函数中重载，因此我们只能重载一个普通的全局函数。为了方便访问对象中的私有数据，声明为友元函数。 1234567891011121314151617181920class myString{ char *str; int size;public: ... friend ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s); friend istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s);};ostream&amp; operator&lt;&lt;(ostream&amp; out,const myString&amp; s) { out&lt;&lt;s.str; return out;}istream&amp; operator&gt;&gt;(istream&amp; in,myString&amp; s) { if(!s.str) { s.str = new char[20]; } in &gt;&gt;s.str; return in;} 这样便可以使用cin和cout来自输入输出了 123myString str;cin &gt;&gt; str;cout&lt;&lt;str&lt;&lt;endl; ++和–运算符重载++和–运算符有前置/后置之分，即++i和i++是有区别的。 前置是一元运算符：++i/–i 重载为成员函数: T &amp; operator++(); T &amp; operator–(); 重载为全局函数： T &amp; operator++(T &amp;); T &amp; operator–(T &amp;); 后置运算符作为二元运算符重载:i++/i– 多写一个参数, 仅为了区分前后置，具体无意义 重载为成员函数: T operator++(int); T operator–(int); 重载为全局函数: T operator++(T &amp;, int); T operator–(T &amp;, int);","link":"/2020/06/03/c-%E9%87%8D%E8%BD%BD/"},{"title":"c++继承“","text":"继承和派生是一件事，指的是子类/派生类通过某种方式继承了父类/基类的成员变量和成员函数。 派生类拥有基类的全部成员函数和成员变量。 派生类中可以扩充新的成员变量和成员函数。 派生类一经定义后，可以独立使用，不依赖于基类。 在派生类的各个成员函数中，不能访问基类中的private成员。 c++中有三种继承方式，分别为public继承、private继承和protected继承。对于基类base:123456789101112131415161718class base{private: int priv; void priFunc() {}protected: int pro; void proFunc() {}public: int pub; void pubFunc() {} base() { cout &lt;&lt; \"base constructor called\" &lt;&lt; endl; }}; public继承 public继承表达的是”is”关系，即子类必须是父类，例如”男人“可以public继承”人“，因为”男人“is”人” 12345678910111213class drive1 : public base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive1() { cout &lt;&lt; \"drive1 constructor called!\"&lt;&lt;endl; }}; public继承会保留基类非私有成员的可见性 1234567drive1 d1;// d1.pri;//error// d1.priFunc();//error// d1.pro;//error// d1.proFunc();//errord1.pub;d1.pubFunc(); public继承的赋值兼容规则1234class base { };class derived : public base { };base b;derived d; 派生类的对象可以赋值给基类对象 b = d; 派生类对象可以初始化基类引用 base &amp; br = d; 派生类对象的地址可以赋值给基类指针 base * pb = &amp; d; 如果派生方式是 private或protected，则上述三条不可行。 private继承 private继承表达的是”根据某物实现出”的关系，即子类通过父类可实现自己成员函数，例如圆形可通过二维点坐标实现自己的一系列方法。 12345678910111213class drive2 : private base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive2() { cout &lt;&lt; \"drive2 constructor called!\"&lt;&lt;endl; }}; private继承会保留基类非私有成员的可见性全部变为private 123drive2 d2;// d2.pub;//error// d2.pubFunc();//error protected继承protected继承会保留基类非私有成员的可见性全部变为protected 123456789101112131415class drive3 : protected base{public: void access() { // cout&lt;&lt;priv&lt;&lt;endl;//error!无法访问基类的私有成员 cout &lt;&lt; pro &lt;&lt; endl; //ok cout &lt;&lt; pub &lt;&lt; endl; //ok } drive3() { cout &lt;&lt; \"drive3 constructor called!\"&lt;&lt;endl; }};drive3 d3;// d3.pubFunc();//error 派生类的构造 派生类构造的时候总是先构造基类，即执行基类的构造函数，然后再执行派生类的构造函数。 12345678910drive1 d1;drive2 d2;drive3 d3;---base constructor calleddrive1 constructor called!base constructor calleddrive2 constructor called!base constructor calleddrive3 constructor called! 调用基类构造函数的两种方式 显式方式: 派生类的构造函数中基类的构造函数提供参数derived::derived(arg_derived-list):base(arg_base-list) 隐式方式: 派生类的构造函数中, 省略基类构造函数时 派生类的构造函数, 自动调用基类的默认构造函数 派生类的析构 派生类析构的时候总是先执行派生类的析构函数，然后再执行基类的析构函数。 123456drive3 d3;---base constructor calleddrive3 constructor called!drive3 destructor calledbase destructor called","link":"/2020/06/06/c-%E7%BB%A7%E6%89%BF/"},{"title":"c++多态与虚函数","text":"在面向对象的程序设计中使用多态，能够增强程序的可扩充性，即程序需要修改或增加功能的时候，需要改动和增加的代码较少。 多态派生类的指针可以赋给基类指针。通过基类指针调用基类和派生类中的同名虚函数时: 若该指针指向一个基类的对象，那么被调用是基类的虚函数； 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class base{public: virtual void baseFunc1() { cout &lt;&lt; \"base1\" &lt;&lt; endl; }};class drive1 : public base{public: virtual void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; }};int main(){ base A;drive1 B;base *ptr; ptr = &amp;A; ptr-&gt;baseFunc1();//base1 ptr = &amp;B; ptr-&gt;baseFunc1();//drive1} 派生类的对象可以赋给基类引用,通过基类引用调用基类和派生类中的同名虚函数时: 若该引用引用的是一个基类的对象，那么被调用是基类的虚函数； 若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。123drive1 B;base &amp;ptr2 = B;ptr2.baseFunc1();//drive1 非构造和非析构函数调用虚函数也是多态 12345678910111213141516171819202122class base{public: base() {baseFunc1();}//没有多态 virtual void baseFunc1() { cout &lt;&lt; \"base1\" &lt;&lt; endl; } void func() {baseFunc1();}//多态};class drive1 : public base{public: //不加virtual也是虚函数，只要基类中是虚函数且同名同参数 void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl;}};int main(){ base A;drive1 B;base *ptr; ptr = &amp;A; ptr-&gt;func(); ptr = &amp;B; ptr-&gt;func();} 为什么构造函数和析构函数调用虚函数没有多态？ new一个派生类对象时，先调用基类的构造函数，此时派生类的成员没有初始化，如果此时去调用派生类的虚函数，那么结果会有问题，无法保证正确性。所以只会用基类定义的虚函数。 delete一个派生类对象时,先调用派生类的析构函数，然后执行基类的析构函数，此时派生类的成员已经被释放掉了，如果此时去调用派生类的虚函数，那么同理，结果会有问题，无法保证正确性。所以只会用基类定义的虚函数。 虚函数在类的定义中，前面有virtual关键字的成员函数就是虚函数。virtual关键字只用在类定义里的函数声明中，写函数体时不用。 1234class base {virtual int vfunc() ;};int base::vfunc() { } 虚函数的实现原理C++给每个声明虚函数的类增加隐藏成员——虚函数表指针（vptr）。虚函数表指针指向一个函数地址数组，这个数组被成为虚函数表（vtable）。虚函数表中存储了类对象声明的虚函数的地址。虚函数表在编译期创建的。基类包含一个虚函数指针vptr1指向虚函数表vtable1，则派生类类将包含指向独立地址表的指针vptr2（不管有没有声明虚函数）指向虚函数表vtable2。 如果派生类提供了基类虚函数的新定义，vfpt2将保存新的函数地址（在vtable1基础上覆盖）; 如果派生类声明了新的虚函数，vtable2将添加该函数地址（在vtable1基础上添加）; 如果派生类仅仅是继承基类的虚函数，那么vtable2将保留原始函数地址（和vtable1保持一致）。 拥有虚函数的基类base123456789class base{ int a;public: base() { baseFunc1(); } //没有多态 virtual void baseFunc1() { cout &lt;&lt; \"base\" &lt;&lt; endl; } virtual void baseFunc2() { cout &lt;&lt; \"base\" &lt;&lt; endl; } void func() { baseFunc1(); } //多态}; 创建一个base类的实例A，则A在内存中的布局： 123A = {_vptr.base = 0x8201cb0 &lt;vtable for base+16&gt;, a = -20237175}(gdb) p sizeof(A)$3 = 16 可以看到A的第一个成员为虚函数表指针vptr，vptr并不是指向vtable的起始处，而是&lt;vtable for base+16&gt;处，即在vtable表头的16偏移处，为了方便我们打印0x8201cb0-16处的内存： 12345(gdb) x /100b 0x8201cb0-160x8201ca0 &lt;_ZTV4base&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201ca8 &lt;_ZTV4base+8&gt;: 0x78 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201cb0 &lt;_ZTV4base+16&gt;: 0x64 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201cb8 &lt;_ZTV4base+24&gt;: 0x9c 0x0f 0x00 0x08 0x00 0x00 0x00 0x00 ZTV4base是指vtable for base，即base类的虚函数表。可以看到base的vtable一共占36字节，具体内容如下： 1234567891011121314(gdb) x /w 0x8201ca00x8201ca0 &lt;_ZTV4base&gt;: 0x00000000(gdb) x /w 0x8201ca80x8201ca8 &lt;_ZTV4base+8&gt;: 0x08201d78(gdb) x 0x08201d780x8201d78 &lt;_ZTI4base&gt;: 0xff3ea7f8(gdb) x /w 0x8201cb00x8201cb0 &lt;_ZTV4base+16&gt;: 0x08000f64(gdb) x 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201cb80x8201cb8 &lt;_ZTV4base+24&gt;: 0x08000f9c(gdb) x 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855 这里ZTI4base指typeinfo of base类，即base的类型声明信息。 123456789 0x8201ca0--&gt;+-----------------------+ | 0 (top_offset) | +-----------------------+A --&gt; +----------+ 0x8201cb0 | ptr to typeinfo for A | | vptr |-----------&gt; +-----------------------+ +----------+ | ptr to base::Func1() | | a | +-----------------------+ +----------+ | ptr to base::Func2() | +-----------------------+ 继承base但没有声明/重写`虚函数的派生类drive1234class drive : public base{ int a;}; 创建一个drive类的实例B，则B在内存中的布局： 1234(gdb) p B$7 = {&lt;base&gt; = {_vptr.base = 0x8201c90 &lt;vtable for drive(gdb) p sizeof(B)$8 = 16 可以看到B的第一个成员为虚函数表指针vptr,注意到vptr和base没有声明或重写任何一个虚函数,但是编译期仍为drive生成了新的虚函数表。我们打印0x8201c90 123456789(gdb) x /100b 0x8201c90-160x8201c80 &lt;_ZTV5drive&gt;: 0x00 0x00 0x00 0x00 0x8201c88 &lt;_ZTV5drive+8&gt;: 0x60 0x1d 0x20 0x000x8201c90 &lt;_ZTV5drive+16&gt;: 0x64 0x0f 0x00 0x000x8201c98 &lt;_ZTV5drive+24&gt;: 0x9c 0x0f 0x00 0x000x8201ca0 &lt;_ZTV4base&gt;: 0x00 0x00 0x00 0x00 8201ca8 &lt;_ZTV4base+8&gt;: 0x78 0x1d 0x20 0xx000x8201cb0 &lt;_ZTV4base+16&gt;: 0x64 0x0f 0x00 0x000x8201cb8 &lt;_ZTV4base+24&gt;: 0x9c 0x0f 0x00 0x00 _ZTV5drive是指vtable for drive，即drive类的虚函数表。可且drive的虚函数表其后紧跟着base的虚函数表。drive的虚函数表具体内容如下： 1234567891011121314(gdb) x /w 0x8201c800x8201c80 &lt;_ZTV5drive&gt;: 0x00000000(gdb) x /w 0x8201c880x8201c88 &lt;_ZTV5drive+8&gt;: 0x08201d60(gdb) x /w 0x8201c900x8201c90 &lt;_ZTV5drive+16&gt;: 0x08000f64(gdb) x /w 0x8201c980x8201c98 &lt;_ZTV5drive+24&gt;: 0x08000f9c(gdb) x /w 0x08201d600x8201d60 &lt;_ZTI5drive&gt;: 0xff3eb438(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000f9c0x8000f9c &lt;base::bFunc2()&gt;: 0xe5894855 12345678910 0x8201c80--&gt;+-----------------------+ | 0 (top_offset) | +-----------------------+B --&gt; +----------+ 0x8201c90 | ptr to typeinfo for B | | vptr |-----------&gt; +-----------------------+ +----------+ | ptr to base::Func1() | | A::a | +-----------------------+ +----------+ | ptr to base::Func2() | | B::a | +-----------------------+ +----------+ 继承base且重写base类虚函数的派生类drive112345678class drive1 : public base{ int b;public: //不加virtual也是虚函数，只要基类中是虚函数且同名同参数 void baseFunc2() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; } virtual void baseFunc1() { cout &lt;&lt; \"drive1\" &lt;&lt; endl; }}; 创建一个drive类的实例B，则B在内存中的布局： 1234(gdb) p C$11 = {&lt;base&gt; = {_vptr.base = 0x8201c70 &lt;vtable for drive1+16&gt;, a = 136321944}, b = 0}(gdb) p sizeof(C)$12 = 16 可以看到C的第一个成员为虚函数表指针vptr,注意到vptr和base的vptr不一样。这说明编译器给drive1生产了新的虚函数表,0x8201c70-16处的内存： 123456(gdb) x /100b 0x8201c70-160x8201c60 &lt;_ZTV6drive1&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201c68 &lt;_ZTV6drive1+8&gt;: 0x48 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201c70 &lt;_ZTV6drive1+16&gt;: 0x0c 0x10 0x00 0x08 0x00 0x00 0x00 0x000x8201c78 &lt;_ZTV6drive1+24&gt;: 0xd4 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c80 &lt;_ZTV5drive&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 _ZTV6drive1是指vtable for drive1，即drive1类的虚函数表。drive1的虚函数表具体内容如下： 1234567891011121314(gdb) x /w 0x8201c600x8201c60 &lt;_ZTV6drive1&gt;: 0x00000000(gdb) x /w 0x8201c680x8201c68 &lt;_ZTV6drive1+8&gt;: 0x08201d48(gdb) x /w 0x08201d480x8201d48 &lt;_ZTI6drive1&gt;: 0xff3eb438(gdb) x /w 0x8201c700x8201c70 &lt;_ZTV6drive1+16&gt;: 0x0800100c(gdb) x /w 0x0800100c0x800100c &lt;drive1::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201c780x8201c78 &lt;_ZTV6drive1+24&gt;: 0x08000fd4(gdb) x /w 0x08000fd40x8000fd4 &lt;drive1::Func2()&gt;: 0xe5894855 12345678910 0x8201c60--&gt;+------------------------+ | 0 (top_offset) | +------------------------+C --&gt; +----------+ 0x8201c70 | ptr to typeinfo for C | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | A::a | +------------------------+ +----------+ | ptr to drive1::Func2() | | C::b | +------------------------+ +----------+ 可以看到drive1的虚函数表中的Func1()和Func2()的函数地址被覆盖为drive1定义的函数。 继承base且声明新的虚函数的派生类drive2123456class drive2 : public base{ int b;public: virtual void Func3() {}}; 创建一个drive类的实例B，则B在内存中的布局： 123$3 = {&lt;base&gt; = {_vptr.base = 0x8201c48 &lt;vtable for drive2+16&gt;, a = 134221601}, b = 0}(gdb) p sizeof(D)$4 = 16 可以看到D的第一个成员为虚函数表指针vptr,注意到vptr和base的vptr不一样。这说明编译器给drive2生产了新的虚函数表,0x8201c48-16处的内存： 1234567(gdb) x /100b 0x8201c48-160x8201c38 &lt;_ZTV6drive2&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x8201c40 &lt;_ZTV6drive2+8&gt;: 0x30 0x1d 0x20 0x08 0x00 0x00 0x00 0x000x8201c48 &lt;_ZTV6drive2+16&gt;: 0x64 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c50 &lt;_ZTV6drive2+24&gt;: 0x9c 0x0f 0x00 0x08 0x00 0x00 0x00 0x000x8201c58 &lt;_ZTV6drive2+32&gt;: 0x44 0x10 0x00 0x08 0x00 0x00 0x00 0x000x8201c60 &lt;_ZTV6drive1&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 drive2的虚函数表具体内容如下： 123456789101112131415161718(gdb) x /w 0x8201c380x8201c38 &lt;_ZTV6drive2&gt;: 0x00000000(gdb) x /w 0x8201c400x8201c40 &lt;_ZTV6drive2+8&gt;: 0x08201d30(gdb) x /w 0x08201d300x8201d30 &lt;_ZTI6drive2&gt;: 0xff3eb438(gdb) x /w 0x8201c480x8201c48 &lt;_ZTV6drive2+16&gt;: 0x08000f64(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x8201c500x8201c50 &lt;_ZTV6drive2+24&gt;: 0x08000f9c(gdb) x /w 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855(gdb) x /w 0x8201c580x8201c58 &lt;_ZTV6drive2+32&gt;: 0x08001044(gdb) x /w 0x080010440x8001044 &lt;drive2::Func3()&gt;: 0xe5894855 12345678910111213141516171819 0x8201c38--&gt;+------------------------+ | 0 (top_offset) | +------------------------+D --&gt; +----------+ 0x8201c48 | ptr to typeinfo for D | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | A::a | +------------------------+ +----------+ | ptr to base::Func2() | | D::b | +------------------------+ +----------+ | ptr to drive2::Func3() | +------------------------+ ``` 可以看到drive1的虚函数表中的Func1()和Func2()的函数地址被#### 继承drive和drive1的派生类moreDrive```c++class moreDrive : public drive,drive1{ int b;}; 创建一个moreDrive类的实例E，则E在内存中的布局： 1234(gdb) p E$5 = {&lt;drive&gt; = {&lt;base&gt; = {_vptr.base = 0x8201c08 &lt;vtable for moreDrive+16&gt;, a = 65535}, a = 1}, &lt;drive1&gt; = {&lt;base&gt; = {_vptr.base = 0x8201c28 &lt;vtable for moreDrive+48&gt;, a = 134221623}, b = 0}, b = 2}(gdb) p sizeof(E)$7 = 40 可以看到有2个虚函数表指针，但是这两个指针指向的是同一个虚数表，只不过这两个指针相对表头的偏移不一样。0x8201c08-16处的内存： 12345(gdb) x /100w 0x8201c08-160x8201bf8 &lt;_ZTV9moreDrive&gt;: 0x00000000 0x00000000 0x08201cf8 0x000000000x8201c08 &lt;_ZTV9moreDrive+16&gt;: 0x08000f64 0x00000000 0x08000f9c 0x000000000x8201c18 &lt;_ZTV9moreDrive+32&gt;: 0xfffffff0 0xffffffff 0x08201cf8 0x000000000x8201c28 &lt;_ZTV9moreDrive+48&gt;: 0x0800100c 0x00000000 0x08000fd4 0x00000000 moreDrive的虚函数表具体内容如下： 123456789101112(gdb) x /w 0x08201cf80x8201cf8 &lt;_ZTI9moreDrive&gt;: 0xff3eb4f8(gdb) x /w 0x08000f640x8000f64 &lt;base::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000f9c0x8000f9c &lt;base::Func2()&gt;: 0xe5894855(gdb) p /d 0xfffffff0$8 = -16(gdb) x /w 0x0800100c0x800100c &lt;drive1::Func1()&gt;: 0xe5894855(gdb) x /w 0x08000fd40x8000fd4 &lt;drive1::Func2()&gt;: 0xe5894855 123456789101112131415161718192021222324252627282930313233343536 0x8201bf8--&gt;+------------------------ | 0 (top_offset) | +------------------------+E --&gt; +----------+ 0x8201c08 | ptr to typeinfo for E | | vptr |-----------&gt; +------------------------+ +----------+ | ptr to base::Func1() | | base::a | +------------------------+ +----------+ | ptr to base::Func2() | | drive::a | +------------------------+ +----------+ | -16 (top_offset) | | vptr |-- +------------------------+ +----------+ | 0x8201c28 | ptr to typeinfo for E | | base::a | ----------&gt; +------------------------+ +----------+ | ptr to drive1::Func1() | | drive1::b| +------------------------+ +----------+ | ptr to drive1::Func2() | | b | +------------------------+ +----------+``` #### 继承drive1和drive2的派生类moreDrive1### 使用虚函数需要注意1. **构造函数可以是虚函数吗?**2. **析构函数可以是虚函数吗?**3. **静态成员函数可以是虚函数吗?**4. **友元函数可以是虚函数吗?**### 纯虚函数和抽象类**纯虚函数**: 没有函数体的虚函数```c++class A { public: virtual void Print( ) = 0 ; //纯虚函数}; 抽象类：包含纯虚函数的类 只能作为基类来派生新类使用 不能创建抽象类的对象 抽象类的指针和引用–&gt;由抽象类派生出来的类的对象 A a; // 错, A 是抽象类, 不能创建对象 A * pa; // ok, 可以定义抽象类的指针和引用 pa = new A; //错误, A 是抽象类, 不能创建对象 在构造函数/析构函数内部不能调用纯虚函数，为什么？","link":"/2020/06/06/c-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"raft","slug":"raft","link":"/tags/raft/"}],"categories":[]}