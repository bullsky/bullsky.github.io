{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/28/hello-world/"},{"title":"RAFT实现之leader election","text":"测试全部通过 leader选举基本流程 所有节点以follower启动 follower的选举时钟超时，转为candidate candidate向其他节点发送投票请求，如果收到过半节点的投票，则成为leader leader周期性向其他节点发送心跳包以维持权威 实现关键点：1.状态转移：raft节点的状态转移要严格依据下图，不管节点处于什么状态，只要发现更大的Term，都转为follower。对于candidate，如果收到新leader的心跳包，则转为follower。 2.选举时钟如果节点状态不是leader，选举时钟需要周期性的检查是否过期: 123456789101112131415func (rf *Raft) PeriodicRequestVote() { for { rf.mu.Lock() //检查状态是不是leader,如果不是，检查election time 有没有超时 ，超时，则状态转为candidate if rf.state != leader &amp;&amp; rf.electionTimer+rf.timeperiod &lt; time.Now().UnixNano() { //转到c尝试成为leader rf.mu.Unlock() rf.AttemptBeLeader() } else { rf.mu.Unlock() } // rf.mu.Unlock() time.Sleep(electionInterval*time.Millisecond) } } 重置选举时钟的3种情形： 从leader处收到appendentriesRPC调用（如果leader的term过期则不用重置） 开始新的一轮选举 给其他节点投票（收到requestVoteRPC调用） 3.RequestVoteRPC接受者（follow，candidate，leader）实现除了图中的1、2，还需要注意： 检查是否收到更大的term，如果收到，更新term并转为follower状态，如果已经是follower，则更新term和重置votedFor 1234567//如果候选人的term小于自己的termif term&lt;rf.currentTerm { reply.VoteGranted = false return} else if term &gt; rf.currentTerm { //收到更高的term，更新term,转为follwer rf.convertToFollwer(term)} 如果决定给候选人投票，需要将自己的当前term返回，这里强调当前term（currentTerm）是因为follower可能因为在正式返回投票结果前更新了自己的currentTerm（比如收到更大的term） 123456if (rf.votedFor==-1 || rf.votedFor==candidateid) &amp;&amp; (lastLogTerm &gt; lastTerm || lastLogTerm==lastTerm &amp;&amp; lastLogIndex&gt;=lastIndex) { reply.Term = rf.currentTerm reply.VoteGranted = true //将投票人修改(add my) rf.votedFor=candidateid 发送者收到RPC调用结果后，需要注意： 是否是过期的rpc回复（即term小于自己的term），丢弃不处理 1234 //如果收到过期的term，丢弃 if rf.state!=candidate || reply.Term &lt; rf.currentTerm { return false } 返回的term是否大于自己的term，是则转为follower 1234 //收到的trem大于自己的term，转为follwer if reply.Term &gt; rf.currentTerm { rf.convertToFollwer(reply.Term) } candidate统计选票时得把自己算上 守护进程定时检查节点是否成为leader，成为leader后定时周期发起AppendEntriesRPC。 123456789101112func (rf *Raft) PeriodicAppendEnties() { for { rf.mu.Lock() if rf.state == leader { rf.mu.Unlock() rf.AttemptReplication() } else { rf.mu.Unlock() } time.Sleep(heartbeatInterval*time.Millisecond) } } 这里可以优化，不需要定时周期检查，当candidate成为leader启动一个历程来周期发起rpc，当发下节点不是leader后，退出改历程。","link":"/2020/05/24/RAFT%E5%AE%9E%E7%8E%B0%E4%B9%8Bleader-election/"}],"tags":[{"name":"分布式系统","slug":"分布式系统","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"}],"categories":[]}